<?xml version="1.0" encoding="UTF-8" ?>
<!ENTITY % visibility-attribute "visibility (public|private|protected) #IMPLIED">
<!ENTITY % kind-attribute "kind (integer|long|real|double) #IMPLIED">
<!ENTITY % mod-final "final CDATA #IMPLIED">
<!ENTITY % mod-static "static CDATA #IMPLIED">
<!ENTITY % mod-volatile "volatile CDATA #IMPLIED">
<!ENTITY % mod-transient "transient CDATA #IMPLIED">
<!ENTITY % mod-native "native CDATA #IMPLIED">
<!ENTITY % mod-abstract "abstract CDATA #IMPLIED">
<!ENTITY % mod-synchronized "synchronized CDATA #IMPLIED">

<!ENTITY % expression-types "send|new|new-array|var-ref|field-access|array-ref|paren|assignment-expr|conditional-expr|binary-expr|unary-expr|cast-expr|literal-number|literal-string|literal-true|literal-false|literal-null|this|super">

<!ELEMENT java-source-program (package-decl?,import*,class+) >
<!ATTLIST java-source-program
    version CDATA #IMPLIED>
<!ELEMENT import EMPTY>
<!ATTLIST import
    module CDATA #REQUIRED>
<!ELEMENT class ((implement)*, (comment|constructor|method|field)*) >
<!ATTLIST class
    name CDATA #REQUIRED
    %visibility-attribute 
    %mod-abstract
    %mod-final
    %mod-synchronized
    superclass CDATA "Object">
<!ELEMENT field (%expression-types)?>
<!ATTLIST field
    type CDATA #REQUIRED
    name CDATA #REQUIRED
    %visibility-attribute
    %mod-final
    %mod-static
    %mod-volatile
    %mod-transient>
<!ELEMENT constructor (comment?,formal-arguments,throws*,(super-call|this-call)?,statements)>
<!ATTLIST constructor
    name CDATA #REQUIRED
    id ID #REQUIRED
    %visibility-attribute
    %mod-final
    %mod-static
    %mod-synchronized
    %mod-volatile
    %mod-transient
    %mod-native>
<!ELEMENT method (comment?,formal-arguments,throws*,statements?)>
<!ATTLIST method 
    name CDATA #REQUIRED
    id ID #REQUIRED
    %visibility-attribute
    %mod-abstract
    %mod-final
    %mod-static
    %mod-synchronized
    %mod-volatile
    %mod-transient
    %mod-native
    return-type CDATA #REQUIRED>
<!ELEMENT comment (#PCDATA)>
<!ELEMENT formal-arguments (formal-argument)*>
<!ELEMENT formal-argument EMPTY>
<!ATTLIST formal-argument
    type CDATA #REQUIRED
    name CDATA #REQUIRED
    %mod-final
    id ID #REQUIRED>
<!ELEMENT send (target,arguments)>
<!ELEMENT target ANY>
<!ELEMENT return ANY>
<!ELEMENT statements (statements|local-variable|try|throw|if|loop|return|continue|break|%expression-types)*>
<!ELEMENT throw ANY>
<!ELEMENT throws EMPTY>
<!ATTLIST throws
    exception CDATA #REQUIRED>
<!ELEMENT new (class-type,arguments)>
<!ELEMENT class-type (#PCDATA)>
<!ELEMENT new-array (array-type,dim-expr*,(%expression-types)?)>
<!ATTLIST new-array
    dimensions CDATA #REQUIRED>
<!ELEMENT dim-expr ANY>
<!ELEMENT array-type (#PCDATA)>
<!ELEMENT local-variable (%expression-types)?>
<!ATTLIST local-variable
    type CDATA #REQUIRED
    name CDATA #REQUIRED
    %mod-final
    id ID #IMPLIED>
<!ELEMENT arguments (%expression-types)*>
<!ELEMENT literal-string EMPTY>
<!ATTLIST literal-string
    value CDATA #REQUIRED
    length CDATA #REQUIRED>
<!ELEMENT literal-number EMPTY>
<!ATTLIST literal-number
    value CDATA #REQUIRED
    %kind-attribute
    base CDATA "10">
<!ELEMENT var-ref EMPTY>
<!ATTLIST var-ref
    name CDATA #REQUIRED>
<!ELEMENT field-access (%expression-types)>
<!ATTLIST field-access
    field CDATA #REQUIRED>
<!ELEMENT package-decl EMPTY>
<!ATTLIST package-decl
    name CDATA #REQUIRED>
<!ELEMENT assignment-expr ANY>
<!ELEMENT binary-expr ((%expression-types),(%expression-types))>
<!ATTLIST binary-expr
    op CDATA #REQUIRED>
<!ELEMENT paren (%expression-types)>
<!ELEMENT unary-expr (%expression-types)>
<!ATTLIST unary-expr
    op CDATA #REQUIRED
    post (yes|no) #IMPLIED>
<!ELEMENT cast-expr (target-type,(%expression-types))>
<!ELEMENT target-type (#PCDATA)>
<!ELEMENT literal-false EMPTY>
<!ELEMENT literal-true EMPTY>
<!ELEMENT literal-null EMPTY>
<!ELEMENT if (test,true-case,false-case?)>
<!ELEMENT test (%expression-types)>
<!ELEMENT true-case (statements)>
<!ELEMENT false-case (statements)>
<!ELEMENT array-ref (base,offset)>
<!ELEMENT base (%expression-types)>
<!ELEMENT offset (%expression-types)>
<!ELEMENT static-initializer (statements)>
<!ELEMENT super-call (arguments)>
<!ELEMENT this-call (arguments)>
<!ELEMENT super EMPTY>
<!ELEMENT this EMPTY>
<!ELEMENT loop (init*,test?,update*,statements?)>
<!ATTLIST loop
    kind (for|while) #IMPLIED>
<!ELEMENT init ANY>
<!ELEMENT update ANY>
<!ELEMENT do-loop (statements?,test?)>
<!ELEMENT try (statements,catch*,finally?)>
<!ELEMENT catch (formal-argument,statements?)>
<!ELEMENT finally (statements)>
<!ELEMENT continue EMPTY>
<!ATTLIST continue
    targetname CDATA #IMPLIED>
<!ELEMENT break EMPTY>
<!ATTLIST break
    targetname CDATA #IMPLIED>
<!ELEMENT conditional-expr ((%expression-types),(%expression-types),(%expression-types))>
