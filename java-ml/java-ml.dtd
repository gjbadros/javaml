<?xml version="1.0" encoding="UTF-8" ?>
<!ENTITY % visibility-attribute "visibility (public|private|protected) #IMPLIED">
<!ENTITY % kind-attribute "kind (integer|long|real|double) #IMPLIED">
<!ENTITY % mod-final "final CDATA #IMPLIED">
<!ENTITY % mod-static "static CDATA #IMPLIED">
<!ENTITY % mod-volatile "volatile CDATA #IMPLIED">
<!ENTITY % mod-transient "transient CDATA #IMPLIED">
<!ENTITY % mod-native "native CDATA #IMPLIED">
<!ENTITY % mod-abstract "abstract CDATA #IMPLIED">
<!ENTITY % mod-synchronized "synchronized CDATA #IMPLIED">

<!ENTITY % expr-elems "send|new|new-array|var-ref|field-access|array-ref|paren|assignment-expr|conditional-expr|binary-expr|unary-expr|cast-expr|literal-number|literal-string|literal-true|literal-false|literal-null|this|super">

<!ELEMENT java-source-program (package-decl?,import*,class+) >
<!ATTLIST java-source-program
    version CDATA #IMPLIED>
<!ELEMENT import EMPTY>
<!ATTLIST import
    module CDATA #REQUIRED>
<!ELEMENT class ((implement)*, (comment|constructor|method|field)*) >
<!ATTLIST class
    name CDATA #REQUIRED
    %visibility-attribute;
    %mod-abstract;
    %mod-final;
    %mod-synchronized;
    superclass CDATA "Object">
<!ELEMENT field (type,(%expr-elems;)?)>
<!ATTLIST field
    name CDATA #REQUIRED
    %visibility-attribute;
    %mod-final;
    %mod-static;
    %mod-volatile;
    %mod-transient;>
<!ELEMENT constructor (comment?,formal-arguments,throws*,(super-call|this-call)?,statements)>
<!ATTLIST constructor
    name CDATA #REQUIRED
    id ID #REQUIRED
    %visibility-attribute;
    %mod-final;
    %mod-static;
    %mod-synchronized;
    %mod-volatile;
    %mod-transient;
    %mod-native;>
<!ELEMENT method (comment?,formal-arguments,throws*,type,statements?)>
<!ATTLIST method 
    name CDATA #REQUIRED
    id ID #REQUIRED
    %visibility-attribute;
    %mod-abstract;
    %mod-final;
    %mod-static;
    %mod-synchronized;
    %mod-volatile;
    %mod-transient;
    %mod-native;>
<!ELEMENT comment (#PCDATA)>
<!ELEMENT formal-arguments (formal-argument)*>
<!ELEMENT formal-argument (type)>
<!ATTLIST formal-argument
    name CDATA #REQUIRED
    %mod-final;
    id ID #REQUIRED>
<!ELEMENT send (target,arguments)>
<!ELEMENT target (%expr-elems;)>
<!ELEMENT return (%expr-elems;)>
<!ELEMENT statements (statements|local-variable|try|throw|if|loop|return|continue|break|%expr-elems;)*>
<!ELEMENT throw ANY>
<!ELEMENT throws EMPTY>
<!ATTLIST throws
    exception CDATA #REQUIRED>
<!ELEMENT new (type,arguments)>
<!ELEMENT type (#PCDATA)>
<!ATTLIST type
    primitive CDATA #IMPLIED
    dimensions CDATA #IMPLIED>
<!ELEMENT new-array (type,dim-expr*,(%expr-elems;)?)>
<!ATTLIST new-array
    dimensions CDATA #REQUIRED>
<!ELEMENT dim-expr ANY>
<!ELEMENT local-variable (type,(%expr-elems;)?)>
<!ATTLIST local-variable
    name CDATA #REQUIRED
    %mod-final;
    id ID #IMPLIED>
<!ELEMENT arguments (%expr-elems;)*>
<!ELEMENT literal-string EMPTY>
<!ATTLIST literal-string
    value CDATA #REQUIRED
    length CDATA #REQUIRED>
<!ELEMENT literal-number EMPTY>
<!ATTLIST literal-number
    value CDATA #REQUIRED
    %kind-attribute;
    base CDATA "10">
<!ELEMENT var-ref EMPTY>
<!ATTLIST var-ref
    name CDATA #REQUIRED>
<!ELEMENT field-access (%expr-elems;)>
<!ATTLIST field-access
    field CDATA #REQUIRED>
<!ELEMENT var-set EMPTY>
<!ATTLIST var-set
    name CDATA #REQUIRED>
<!ELEMENT field-set (%expr-elems;)>
<!ATTLIST field-set
    field CDATA #REQUIRED>
<!ELEMENT package-decl EMPTY>
<!ATTLIST package-decl
    name CDATA #REQUIRED>
<!ELEMENT assignment-expr (lvalue,(%expr-elems;))>
<!ELEMENT lvalue (var-set|field-set|%expr-elems;)>
<!ELEMENT binary-expr ((%expr-elems;),(%expr-elems;))>
<!ATTLIST binary-expr
    op CDATA #REQUIRED>
<!ELEMENT paren (%expr-elems;)>
<!ELEMENT unary-expr (%expr-elems;)>
<!ATTLIST unary-expr
    op CDATA #REQUIRED
    post (yes|no) #IMPLIED>
<!ELEMENT cast-expr (type,(%expr-elems;))>
<!ELEMENT literal-false EMPTY>
<!ELEMENT literal-true EMPTY>
<!ELEMENT literal-null EMPTY>
<!ELEMENT if (test,true-case,false-case?)>
<!ELEMENT test (%expr-elems;)>
<!ELEMENT true-case (statements)>
<!ELEMENT false-case (statements)>
<!ELEMENT array-ref (base,offset)>
<!ELEMENT base (%expr-elems;)>
<!ELEMENT offset (%expr-elems;)>
<!ELEMENT static-initializer (statements)>
<!ELEMENT super-call (arguments)>
<!ELEMENT this-call (arguments)>
<!ELEMENT super EMPTY>
<!ELEMENT this EMPTY>
<!ELEMENT loop (init*,test?,update*,statements?)>
<!ATTLIST loop
    kind (for|while) #IMPLIED>
<!ELEMENT init ANY>
<!ELEMENT update ANY>
<!ELEMENT do-loop (statements?,test?)>
<!ELEMENT try (statements,catch*,finally?)>
<!ELEMENT catch (formal-argument,statements?)>
<!ELEMENT finally (statements)>
<!ELEMENT continue EMPTY>
<!ATTLIST continue
    targetname CDATA #IMPLIED>
<!ELEMENT break EMPTY>
<!ATTLIST break
    targetname CDATA #IMPLIED>
<!ELEMENT conditional-expr ((%expr-elems;),(%expr-elems;),(%expr-elems;))>
