!--$Id$-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>
JavaML: A Markup Language for Java Source, by Greg J. Badros
</title>
<!--
  Title 
  Authors 
  Affiliations 
  Abstract 
  Keywords 
  Main body of text 
  Acknowledgements 
  Appendix 
  References 
  Vitae 
-->
<STYLE TYPE="text/css">
<!--
BODY { BACKGROUND-COLOR: #ffffff; FONT-FAMILY: arial, times new roman, sans-serif; }
A:link, A:visited, A:active { TEXT-DECORATION: none; FONT-WEIGHT: bold; COLOR: #0000FF}

H1, H2 { TEXT-ALIGN: center; FONT-WEIGHT: bold; }
H3, H4, H5 { TEXT-ALIGN: left; FONT-WEIGHT: bold; }
H6 { TEXT-ALIGN: center; FONT-WEIGHT: bold; FONT-SIZE: small; }
H6.CAPTION { TEXT-ALIGN: center; FONT-WEIGHT: bold; FONT-SIZE: small; FONT-STYLE: italic; }

P { TEXT-INDENT: 1em; }
P.CODE { TEXT-INDENT: 0; COLOR: #FF0000; }

UL, OL, DL { MARGIN-LEFT: 2em; FONT-SIZE: medium; }
UL { list-style: square; }
LI { FONT-SIZE: small; FONT-WEIGHT: bold; }
UL EM, OL EM { FONT-WEIGHT: bold; }
CODE, CITE { FONT-WEIGHT: bold; }
DD { MARGIN-TOP: 5em; margin-left: 5em }

BLOCKQUOTE { MARGIN-LEFT: 1em; MARGIN-RIGHT: 1em }
IMG { VERTICAL-ALIGN: top; ALIGN: center; }
SUP { COLOR: #0000FF; FONT-SIZE: small; }

-->
</STYLE>
</head>
<body>
<h2>
<a name="top">JavaML: A Markup Language for Java Source Code</a>
</h2>
<h6>Greg J. Badros<br>
University of Washington</h6>

<hr>
<a href="#introduction">Introduction</a> &nbsp;
<a href="#background">Background</a> &nbsp;
<a href="#javaml">JavaML</a>  &nbsp;
<a href="#leveraging-xml">Leveraging XML</a> <br>
<a href="#related-work">Related work</a>  &nbsp;
<a href="#future-work">Future work</a>  &nbsp;
<a href="#conclusion">Conclusion</a>  &nbsp; 
<a href="#acknowledgments">Acknowledgments</a>  <br>
<a href="#javaml-dtd">Appendix 1 - JavaML DTD</a> &nbsp;
<a href="#set.java">Appendix 2a - Extended Example,
      <strong>Set.java</strong></a>  &nbsp;
<a href="#set.java.xml">Appendix 2b - Extended Example,
      <strong>Set.java.xml</strong></a>  <br>
<a href="#references">References</a>  &nbsp;
<a href="#vitae">Vitae</a> 

<hr>

<h3><a name="abstract">Abstract</a></h3>

      The typical plain-text representation of source code is convenient
      for programmers but requires parsing to uncover the deep structure
      of the program.  While sophisticated software tools parse source
      code to gain access to the program's structure, many lightweight
      programming aids such as <tt>grep</tt> rely instead on only the
      lexical structure of source code.  I describe a new XML
      application that provides an isomorphic alternative representation
      of Java source code. This XML-based representation, called JavaML,
      is more natural for tools and permits easy specification of
      numerous software-engineering analysis by leveraging the plethora
      of XML tools and techniques.  A robust converter built with the IBM
      Jikes Java compiler framework translates from plain-text Java
      source code to JavaML.  I argue that the plain-text representation
      should be viewed as only artifact of the interactive
      program-editing process, and that JavaML is a better primary
      representation format for Java programs.

<h3><a name="keywords">Keywords</a></h3>

Java, source-code, SGML, XML, abstract syntax tree, AST, parsing,
analysis, software-engineering, Jikes

<h3><a name="introduction">1 - Introduction</a></h3>

Since the first computer programming languages, a text representation
has been used as the medium for encoding software structure and
computation.  Over the years, techniques have been developed that
largely mechanize the front-end of compilers which perform the lexical
analysis and parsing necessary to uncover the structure of programming
language constructs represented as plain text.  Tools such as Lex/Flex
and Yacc/Bison <cite>[LexYacc]</cite> automate these uninteresting tasks
by using well-founded concepts of regular expressions and
grammars. Regular expressions describe how individual characters combine
to form tokens, and the grammar enumerates how higher-level constructs
are composed of tokens and more primitive constructs.  Together, these
procedures convert from a sequence of characters into a data structure
called an <em>abstract syntax tree</em> (AST) that more directly
reflects the structure of the source program.

<p>

The textual representation of source code has several nice properties.
It can be concise and is similar to natural languages thus often making
it easy to read.  Text is a universal data format thus making source
code easy to exchange and manipulate using a wide variety of tools
including text editors, version control systems, and command pipeline
utilities such as <code>grep</code>, <code>awk</code>, and
<code>wc</code>.

<p>

Nevertheless, the <em>plain old source representation</em> (hereafter abbreviated
POSR) has numerous problems.  The syntax of popular contemporary
languages such as C++ and Perl push the limits of parsing capabilities
(witness the <code>typename</code> keyword in C++ that is necessary to
resolve an ambiguity in template-based code).  Constructing a front end
for such languages is a difficult task despite the support from grammar
tools.  Perhaps more disconcerting is that evolving the syntax of the
language often requires manipulating a fragile grammar.  This limitation
complicates handling an evolving language, but is a difficulty even for
stable grammars because it disallows the possibility of user-defined
syntactic extensions.

<p>

Another problem with the POSR is that parsing is not very
robust.  A small change in the source code can have a dramatic effect on
the resulting AST and thus the semantics of the computation.  For
example, a single extraneous semicolon can change a looping block into
an ordinary one and result in an infinite loop:

<code>
<pre>
  int i = 10;
  while (i > 0);
    {
    // ...
    --i;
    }
</pre>
</code>

Other, more-concise languages suffer from far more disastrous semantic
changes stemming from small syntactic errors (Perl is the infamous
example).

 <h4><a name="tools">1.1 - Text representation and software tools</a></h4>

Probably the most disturbing problem with the POSR is that the structure
of the program is made manifest only after parsing.  This shortcoming
forces language-specific parsing functionality to be duplicated in every
tool that needs to reason about the program beyond its lexical nature.
Compilers, by necessity, must work with the AST, but numerous other
software-engineering tools would perform better with access to the
structured representation of the source code.  Unfortunately, many
software-engineering tools do not embed a parser and thus are limited to
lexical reasoning.

<p>

There are several reasons why embedding a parser is avoided in many
tools.  As mentioned previously, building a complete front-end is
challenging for syntactically-complex languages.  Though re-using
existing infrastructure (e.g., the grammar definition) simplifies
things, the resulting AST is not always intuitive to work with.  A
typical AST reflects quirky artifacts of the grammar rather than
representing the programming-level constructs directly.  Additionally,
embedding the front-end of a compiler can deemed overkill when targeting
a simple analysis that can do "good enough" with lexical information.

<p>

Other complications arise if a transformation of the source code is
desired: a change in the AST must ultimately be reflected in the POSR
since that is the primary long-term representation.  This is most
straightforwardly done using an unparsing approach that can create
undesired lexical side effects (e.g., changes in indentation or
whitespace) that confuse the other lexical tools that the developer is
relying upon (e.g., a version control system that is unable to
disambiguate between a meaningful change and a gratuitous one affected
unintentionally).  Finally, using a parser in a tool necessarily targets
that tool to a specific language, thus reducing its applicability and
generality.  Worse, since there is no canonical structured
representation of a source program, supporting interoperability of
independent tools even targeting the same programming language is
very difficult.

<p>

The end result of these complications is that developers often use
simple, lexically-oriented tools such as <code>grep</code> or search and
replace within an editor.  This approach sacrifices accuracy:
imagine wanting to rename a local variable from <code>result</code> to
<code>answer</code>.  With simple search and replace, all occurrences of
the word will be changed, even if they refer to characters inside
comments, literal strings, or an unrelated instance field.

<p>

An alternate route taken by some developers is that they rely instead on
a fixed set of tools provided within an integrated development
environment (IDE) that has access to the structure of their source
program via an integrated language-specific parser.  This approach
sacrifies flexibility.  IDEs generally provide only a limited set of
capabilities and extending those is hard.  Additionally, analyses and
transformation on source code are often hard to automate or perform in
batch using exisiting interactive environments.  Some more advanced
IDEs, such as IBM VisualAge for C++ <cite>[Montana]</cite>, expose an
application programming interface to the representation of the program.
Though an improvement, such a technique still suffers from an inability
to separate simple tools from a complex environment and additionally
creates a dependency on proprietary technology that may be undesirable.

 <h4><a name="solution">1.2 - A solution</a></h4>

One of the fundamental problems underlying the above difficulties is the
lack of a canonical representation of the structure of source code.
What we need is a universal format for representing the structure that
is so important to preserve, analyze, and manipulate.  The key
observation is that XML, the eXtensible Markup Language, provides
exactly this capability and can be used to represent source code.  

<p>

In this paper, I introduce the Java Markup Language, JavaML -- an XML
application for describing Java source programs.  The JavaML document
type definition (DTD) specifies the various elements of a valid JavaML
document.  There is a natural correspondence between the elements and
their attributes and the programming language constructs they model.
The structure of the source program is reflected in the nesting of
elements in the JavaML document.  With this representation, we can then
leverage the wealth of tools for manipulating and querying XML and SGML
documents to provide a rich infrastructure for software engineering
transformations and analyses on Java source code.  

<p>

JavaML is well-suited to be used as a canonical representation of Java
source code.  It shares most of the strengths of the POSR and overcomes
many weaknesses.  The <a href="#background">next section</a> describes
relevant features of Java and XML and the <a href="#javaml">following
section</a> details the markup language and the implementation of a
converter from the POSR to JavaML.  <a href="#leveraging-xml">Section
4</a> gives numerous examples of how existing XML and SGML tools can be
exploited to perform source code analyses and transformations on the
richer representation provided by JavaML.  Sections <a href="#related
work">5</a> and <a href="#future-work">6</a> describe others' related
work and suggest avenues for exciting future work, respectively.
Finally, <a href="#conclusion">Section 7</a> concludes.

<p>

The full document type definition for JavaML appears in <a
href="#javaml-dtd">Appendix 1</a> and an example of converted source code
is given in Appendices <a href="#set.java">2a</a> and <a
href="#set.java.xml">2b</a>.


<p><span class="index"><a href="#top">[top]</a></span>

<h3><a name="background">2 - Background</a></h3>

The Java Markup Language is influenced by and benefits from numerous of the
features of the two technologies it builds a bridge between: Java and XML.

 <h4><a name="java">2.1 - Java</a></h4>

    Though the XML-based representation of programming language
    constructs is language independent and could be applied to any of a
    number of conventional languages, Java is an excellent candidate for 
    experimenting with these ideas and techniques.

<p>

    Java is a popular object-oriented programming language developed by
    Sun Microsystems in the mid-1990s.  It features a
    platform-independent execution model based on the Java Virtual
    machine (JVM) and owes its early popularity to its use as a
    programming language for World Wide Web applications.  Java combines
    a simple object model reminiscent of Smalltalk with Algol block
    structure, a C++-like syntax, a static type system, and a package
    system inspired by Modula-2. <cite>[Java,JavaNutshell]</cite>

<p>

   As in other object-oriented (OO) languages, the primary unit of
   decomposition in Java is a "class" which specifies the behaviour of a
   set of objects.  Each class can define several "methods," or
   behaviours, similar to functions or procedures. A class can also
   define "fields," or state variables, that are associated with
   "instances" of the class called "objects." Classes can inherit
   behaviour and state from "superclasses," thus forming a hierarchy of
   inter-related classes that permits factoring related code into
   classes at the top of the hierarchy, and encourages re-use.
   Behaviours are invoked by sending a "message" to a target receiver
   object that is a request to execute a method defined for that class.
   Choosing what method to execute in response to a message is called
   "dynamic dispatch" and is based on the run-time class of the object
   receiving the message.  For example, an instance of the "ColoredBall"
   class may respond to the "draw" message differently than an instance
   of a "Ball" class.  This ability to behave differently upon receipt
   of the same message is called polymorphism and is largely responsible
   for the extensibility benefits touted by the OO community.
    
<p>
      
   Java is being widely used both in industry and in education, and it
   remains popular as a programming language on the web.  Unlike C++, a
   Java class definition exists in a single, self-contained file.  There
   are no separate header files and implementation files, and Java is
   largely free from order-dependencies of definitions.  A method body
   is defined with the declaration of the method signature Additionally,
   Java lacks an integrated preprocessor.  These features combine to
   make Java source programs syntactically very clean, and make Java an
   ideal language for representing using XML.

  <h4><a name="xml">2.2 - XML: Extensible Markup Language</a></h4>

XML is a standardized extensible markup language that is a subset of
SGML, the standard Generalized Markup Language.  The World Wide Web
Consortium (W3C) designed XML to be lightweight and simple, while
retaining compatibility with SGML.  Though HTML (HyperText Markup
Language) is currently the standard language, the W3C is positioning XML
to be its replacement.  While HTML permits authors to use only a
pre-determined fixed set of tags in marking up their document, XML
allows easy specification of user-defined markup tags adapted to the
document and data at hand. <cite>[XML-Rec,LaTeXWeb,XML-Handbook]</cite>

<p>

An XML document consists simply of text marked up with tags enclosed in
angle braces.  A simple example is:

<code>
<pre>
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE email SYSTEM "email.dtd"&gt;
&lt;email&gt;
  &lt;head&gt;
    &lt;to&gt;Mom&lt;/to&gt;
    &lt;from&gt;Greg&lt;/from&gt;
    &lt;subject&gt;My trip&lt;/subject&gt;
  &lt;/head&gt;
  &lt;body encoding="ascii"&gt;Weather is terrific&lt;/body&gt;
&lt;/email&gt;
</pre>
</code>

The <code>&lt;email&gt;</code> is an open tag for the <code>email</code>
element.  The <code>&lt;/email&gt;</code> at the end of the example is the
corresponding close tag.  Text and other nested tags can appear between
the open and close constructs.  In the above, the <code>email</code>
element contains two elements: a <code>head</code> and a
<code>body</code>.  Additionally, an XML open tag can associate
attribute/value pairs with an element.  The <code>body</code> element
above has the value <code>ascii</code> for its <code>encoding</code>
attribute.  For an XML document to be <em>well-formed</em>, the
document must simply conform to the numerous syntactic rules required of
XML documents (e.g., tags must be balanced and properly nested,
attribute values must be of the proper form and enclosed in quotes,
etc.).

A more stringent characterization of an XML document is
<em>validity</em>.  An XML document is valid if and only if it is
both well-formed and adheres to its specified <em>document type
definition</em>, or <em>DTD</em>.  A document type definition is a
formal description of the grammar of the specific language to be used by
a class of XML documents.  A DTD defines all the permitted element
names, and describes the attributes that each kind of element may
posess. It also restricts the structure of the nesting within a valid
XML document.  The above XML example is valid with respect to the
following DTD:

<code>
<pre>
&lt;!-- email DTD --&gt;
&lt;!ELEMENT email (head,body)&gt;
&lt;!ELEMENT head (to,from,subject?)&gt;
&lt;!ELEMENT to (#PCDATA)&gt;
&lt;!ELEMENT from (#PCDATA)&gt;
&lt;!ELEMENT subject (#PCDATA)&gt;
&lt;!ELEMENT body (#PCDATA)&gt;
&lt;!ATTLIST body
    encoding (ascii|mime) #REQUIRED&gt;
    encrypted (yes|no) #IMPLIED&gt;
</pre>
</code>

According to this DTD, there are six element classes. The
<code>email</code> element must contain exactly one <code>head</code>
followed by exactly one <code>body</code> element.  The
<code>head</code>, in turn, must contain <code>to</code> and
<code>from</code> elements, in that order, followed by an optional
<code>subject</code> element.  Each of those elements may contain parsed
character data (<em>PCDATA</em>).  The single <code>ATTLIST</code>
declaration in the DTD specifies that the <code>body</code> element
<em>must</em> specify a value of either <code>ascii</code> or
<code>mime</code> for the <code>encoding</code> attribute, and
<em>may</em> specify a value for the <code>encrypted</code> attribute.
A XML document that is declared to adhere to this DTD is not valid if
any of the above criteria are not met.  For example, if the
<code>to</code> element is missing from an <code>email</code> document,
that document is not valid, though it may still be well-formed.

<p>

When modeling data in XML, a primary design decision is choosing whether
to nest elements or to use attributes.  In the above example, we could
      have folded all of the information contained in the
      <code>head</code> into attributes of the <code>email</code>
      element if we chose.  There are several important differences
      between using attributes and nesting elements:

<ul>

<li> Attributes/value pairs are unordered, while nested children have a
specific order;

<li> values for attributes may contain only character data, and may not
include other markup, while nested children can arbitrarily nest
further;

<li> only one value for an attribute can be given, while multiple
elements of the same class can be included by a parent element (e.g., we
could have multiple <code>to</code> elements contained by the
<code>head</code> with only a simple change to the DTD).

</ul>

Though the above limitations sometimes mandate using one technique or
the other, the decision is often initially a matter of taste.  However,
later experiences in using the resulting documents may suggest
revisiting the decision in order to simplify some useful manipulation of
the document.

<p>

<!--GJB:FIXME:: lots of cite s here--> 

XML, in part due to its SGML heritage, is very well supported by tools
such as Emacs editing modes, structure-based editors, DTD parsers and
editors, validation utilities, querying systems, transformation and
style languages, and much more.  Many other W3C recommendations
inter-relate to XML including Cascading Style Sheets
<cite>[CSS2]</cite>, XSL (Extensible Stylesheet Language)
<cite>[XSL]</cite> and XSLT (XSL for Transformations)
<cite>[XSLT]</cite>, XPath <cite>[XPath]</cite>, and DOM (Document
Object Model) <cite>[DOM]</cite>.

<p><span class="index"><a href="#top">[top]</a>

<h3><a name="javaml">3 - JavaML: The Java Markup Language</a></h3>

The Java Markup Language provides a complete self-describing
representation of Java source code.  Unlike the conventional
character-based representation of programs, JavaML reflects the
structure of the software artifact directly in the nesting of elements
in the XML-based syntax.  Since XML is a text-based representation, many
of the advantages of the plain old source representation remain. Since
JavaML is an XML application, JavaML is incredibly easy to parse, and
all existing tools for working with XML can be applied to Java source
code in its JavaML representation.  Future JavaML tools can leverage the
existing infrastructure while exploiting the canonical representation to
improve interoperability.

<p>

Though the basic approach of using an XML application to model source
code is fairly straightforward, there is a large design space of
possible markup language.  The most obvious possibility is to simply use
XML as a textual dump format of a typical abstract syntax tree derived
from parsing source code.  Consider the simple Java program:

<code>
<pre>
import java.applet.*;
import java.awt.*;

public class FirstApplet extends Applet {
  public void paint(Graphics g) {
    g.drawString("Hello World", 25, 50);
  }
}
</pre>
</code>

Performing the obvious (but very unsatisfying) translation from the AST
of the above might result in the below <em>for just the first line of code</em>:

<code>
<pre>
&lt;compilation-unit&gt;
 &lt;ImportDeclarationsopt&gt;
  &lt;ImportDeclarations&gt;
   &lt;ImportDeclaration&gt;
    &lt;TypeImportOnDemandDeclaration&gt;
      import
      &lt;Name&gt;
       &lt;QualifiedName&gt;
        &lt;Name&gt;
         &lt;SimpleName&gt; java &lt;/SimpleName&gt;
        &lt;/Name&gt;
        .
        &lt;Name&gt;
         &lt;SimpleName&gt; applet &lt;/SimpleName&gt;
        &lt;/Name&gt;
       &lt;QualifiedName&gt;
      &lt;/Name&gt;
       . * ;
    &lt;/TypeImportOnDemandDeclaration&gt;
   &lt;/ImportDeclaration&gt;
  &lt;/ImportDeclarations&gt;
 &lt;/ImportDeclarationsopt&gt;
...
&lt;compilation-unit&gt;
</pre>
</code>

Certainly this is far from ideal.  It is unacceptably verbose, exposes
numerous details of the underlying grammar that was used to do the
initial parse from the POSR, and would be difficult to work with because
of the excessive number of nodes.

<p>

An alternate possibility is to literally mark-up the Java source program
to add value to the basic sequence of characters.  This approach might
convert the <code>FirstApplet.java</code> implementation to:

<code>
<pre>
&lt;java-source-program&gt;
&lt;import-declaration&gt;import java.applet.*;&lt;/import-declaration&gt;
&lt;import-declaration&gt;import java.awt.*;&lt;/import-declaration&gt;

&lt;class-declaration&gt;
&lt;modifiers&gt;public&lt;/modifiers&gt; class 
   &lt;class-name&gt;FirstApplet&lt;/class-name&gt; 
     extends &lt;superclass&gt;Applet&lt;/superclass&gt; {
 &lt;method-definition&gt;
  &lt;modifiers&gt;public&lt;/modifiers&gt; &lt;return-type&gt;void&lt;/return-type&gt; 
    &lt;method-name&gt;paint&lt;/method-name&gt;
      (&lt;formal-arguments&gt;&lt;type&gt;Graphics&lt;/type&gt; 
             &lt;name&gt;g&lt;/name&gt;&lt;/formal-arguments&gt;) 
    &lt;statements&gt;{
    g.drawString("Hello World", 25, 50);
  } &lt;/statements&gt;
 &lt;/method-definition&gt;
}
&lt;/class-declaration&gt;
&lt;/java-source-program&gt;
</pre>
</code>

This is a huge step forward.  We have definitely added value to the
representation, and it is trivial to convert back to the POSR: we simply
remove all tags and leave the content of the elements behind (this is
exactly what the <code>stripsgml</code> <cite>[PerlSGML]</cite> utility
does).  Though this representation seems useful for many tasks, it still
has some problems.  First, many of the details of the code are included
in the textual content of elements.  If we want to determine what
packages are being imported, our XML query would need to lexically
analyze the content of the import-declaration elements.  This is
inconvenient and is not making the most of the capabilities that XML
provides.  Perhaps more significantly, the above XML representation
retains artifacts from the POSR that another representation might permit
us to abstract away from and free ourselves of those syntactic burdens
altogether.

<h4><a name="our-representation">Our JavaML representation</a></h4>

The prototype JavaML representation we have chosen aims to model the
programming language constructs of Java (and, indeed, similar
object-oriented programming languages) independently of the specific
syntax of the language.  One can easily imagine a SmalltalkML that would 
be significantly the same, and even an OOML that could be converted into 
both Java POSR or Smalltalk file-out format.  With this goal in mind,
JavaML was designed from first principles of the constructs and
iteratively refined based on complexity of conversion and usefullness
and readability of the resulting markup langauge.

<p>

For the example <code>FirstApplet.java</code> listed above, we represent 
the program in JavaML as:

<code>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE java-source-program SYSTEM "java-ml.dtd"&gt;

&lt;java-source-program name="FirstApplet.java"&gt;
  &lt;import module="java.applet.*"/&gt;
  &lt;import module="java.awt.*"/&gt;
  &lt;class name="FirstApplet" visibility="public" superclass="Applet"&gt;
    &lt;method name="paint" visibility="public" id="meth-15"&gt;
      &lt;type name="void" primitive="true"/&gt;
      &lt;formal-arguments&gt;
	&lt;formal-argument name="g" id="frmarg-13"&gt;&lt;type name="Graphics"/&gt;&lt;/formal-argument&gt;
      &lt;/formal-arguments&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;send message="drawString"&gt;
	    &lt;target&gt;&lt;var-ref name="g" idref="frmarg-13"/&gt;&lt;/target&gt;
	    &lt;arguments&gt;
              &lt;literal-string length="13"&gt;Hello World&lt;/literal-string&gt;
              &lt;literal-number kind="integer" value="25"/&gt;
              &lt;literal-number kind="integer" value="50"/&gt;
            &lt;/arguments&gt;
	  &lt;/send&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
  &lt;/class&gt;
&lt;/java-source-program&gt;
</pre>
</code>

In the above, concepts such as methods, superclasses, message sends, and
literal numbers are all directly represented in the elements and
attributes of the representation.  The structure of the programming
languages is reflected in the nesting of the elements: the literal
string "Hello World" is a part of the message send thus the
<code>literal-string</code> element is nested inside the
<code>send</code> element.  See <a href="javaml.dtd">Appendix 1</a> for
    the complete document type definition of JavaML.

<p>

<h4><a name="design-decisions">Design decisions</a></h4>

JavaML provides more than just the structure of the source program,
though.  In the above, notice the use of the formal-argument
<code>g</code> in the target of the message send.  The
<code>idref</code> attribute of that <code>var-ref</code> tag points
back at the referenced <code>formal-argument</code> element (through its
<code>id</code> attribute).  This linking is standard XML, thus XML
tools are able to trace from a variable use to its definition to, e.g.,
obtain the type of the variable.  Similar linking is done for local
(block-declared) variables.  In JavaML, variable references are easy to
locate because of their distinguishing <code>var-ref</code> tag.
Additionally, they are disambiguated from an assignment to a variable
which is converted into a <code>var-set</code> tag.

<p>

Throughout JavaML, attributes of elements are used whenever the
structure of the value is never more complex than a simple text string.
Attributes are used for modifiers such as <code>synchronized</code> and
<code>final</code> and for visibility settings such as
<code>public</code> or <code>private</code>.  Attributes are not used
for properties such as types because they have richer structure: a type
can consist of a base name and a number of dimensions, and could also
reference the definition of the class that implements the type, if
desired.  If, say, a return type were just the value of an attribute on
the method element, the end user would unacceptably have to do string
processing on the value <code>int[][]</code> to determine that the base
type of a two-dimensional array was just the primitive type
<code>int</code>.

<p>

In JavaML, important characteristics of elements are stressed over less
important features, but those less important distinctions are preserved.
For example, <code>45</code> and <code>3.2</code> are represented as:
<code>&lt;literal-number kind="integer" value="45"&gt;</code> and
<code>&lt;literal-number kind="float" value="3.2"&gt;</code>,
respectively.  An alternate possible markup is:
<code>&lt;literal-integer value="45"&gt;</code> and
<code>&lt;literal-float value="3.2"&gt;</code> but using separate
element classes eliminates the tight relationship that both values are
numbers and can complicate using the representation.  By instead
disambiguating these literals based on a kind attribute, we can still
tell the difference between a floating point literal and an integer
literal, but in the common case we gain the same flexibility of numeric
types that the Java language has.

<p>

Another place where we generalized language constructs when designing
JavaML is in loops.  Both <code>for</code> and <code>while</code> loops
can be viewed as general looping constructs with 0 or more initializers,
a guarding test that occurs before each iteration, 0 or more update
operations, and a body of statements that comprise the looped-over
instructions.  Thus, instead of using two classes of elements,
<code>for-loop</code> and <code>while-loop</code>, JavaML uses a single
<code>loop</code> element that has a <code>kind</code> attribute with
value either <code>for</code> or <code>while</code>.  When a
<code>while</code> loop is converted, it will have no initializer and
update children, yet a <code>for</code> loop code potentially multiple
of each.  In contrast <code>do-loop</code> elements are used for
<code>do</code> loops which have their test performed at the end of the
loop, instead of at the start.

  <!--Talk about unparsing loops kind="while" w/ initializer? [as result
  of transformation, say] We definitely can do it, and it's pretty cool
  -->
      
<p>

As yet another example, we represent both instance and class (i.e.,
static) fields as <code>field</code> elements with a <code>static</code>
attribute used to disambiguate.  Though there are more substantial
differences between these two concepts than between <code>while</code>
and <code>for</code> loops, it still seems beneficial to use a single
element class for both concepts.

<p>

Local variable declarations provide a syntactic shorthand that raises an
interesting question about their underlying representation.  The code
segment:

<code>
<pre>
  int x, y;
</pre>
</code>

defines two variables both of type <code>int</code>, but with perhaps a
subtle additional intention: that the two variables have the same type.
For contrast, consider:

<code>
<pre>
  int weight, i;
</pre>
</code>

Here, there probably is <em>not</em> the implicit desire that the two
variables have the same type, but instead the shorthand syntax is being
used simply for brevity.  Since it is hard to automate distinguishing
these cases, JavaML simply preserves this syntactic feature by using a
<code>continuation="true"</code> attribute on variable declarations that
exploit this shorthand.

<h4><a name="implementation">Implementation of converter</a></h4>

To experiment with the design of JavaML and gain experience in using the
representation, it was essential to implement a converter from the Java
plain old source representation to JavaML.  Within the IBM Jikes Java
compiler framework <cite>[Jikes]</cite>, I added an
<code>XMLUnparse</code> method to each of the Ast nodes. This change,
along with some small additional code for managing the options to
request the XML output, results in an incredibly robust and fast POSR to
JavaML converter.  In total, I added about 1600 non-comment-non-blank
lines of C++ code to the Jikes framework to support the option.  The
source code is available upon request (and will be made publically
available shortly after final submission of this paper).

The converter has been tested by converting several sample programs, as
well as the whole of the 4300 line Cassowary Constraint Solving Toolkit
<cite>[Cassowary]</cite>.  The conversion of all those files takes only
about six seconds on the author's RedHat6-based Pentium III-450 machine.
Each of the files converted was then validated with respect to the
JavaML DTD using James Clark's Jade package's <code>nsgmls</code> tool.
The converter was debugged until all of the files were deemed valid.

Also developed is a prototype back-converter that outputs the POSR given
the JavaML representation. written in Perl using the XML and DOM
packages.  See the <a href="#future-work">Section 6</a> for more about
back-converting possibilities.

<p><span class="index"><a href="#top">[top]</a></span>

<h3><a name="leveraging-xml">4 - Leveraging XML</a></h3>
<!-- example uses -->

*** examples include diffing source code, code metrics, searches,
transformations such as renaming a local variable, etc. -> leveraging 


<p><span class="index"><a href="#top">[top]</a></span>

<h3><a name="related-work">5 - Related work</a></h3>
<pre>

SGML/XML tools discussed in prior section.

TAWK

ASTLog

CCEL

Intentional Programming
*** easy to extend and change -> future work re: IP

Structured Editors
</pre>

<p><span class="index"><a href="#top">[top]</a></span>

<h3><a name="future-work">6 - Future work</a></h3>
<pre>

Not tied to Java-- could be used w/ other languages, or to translate
between languages, or to interact w/ graphical tools, etc.
-> C++ has difficulties because of cpp


Comments need to be preserved;  attaching them may be a bit tricky, but
    is helped by JavaDoc conventions.

Robust converter back to plain Java source.  Ideally do this with Jikes
    and a XML DOM -> Jikes AST function, then let Jikes unparse and then 
    indent.   Added benefit:  throw out posr from compiler altogether,
Semantic analysis phase of compiler is simplified
 -> some analysis handled by validity check
   -> it'd be interesting to see which semantic errors jikes
      reports are handled by the XML validity check on my DTD
 -> well-formedness doesn't give us much, though


Another possibility: a DSSSL pretty printer from the JavaML source to
	plain java source.  No need for a parser in the pretty printer!

More id/idref matchups -- types to their class definitions in other
files, etc.

Redo some of the related work in the context of this more principled
	approach.

New abstractions?  Define a JavaML++ DTD w/ that abstraction, and
	provide a JavaML++ -> JavaML transformation.  Bit like the
	enzymes in IP.

XML editors that display and let edit on the
	plain-old-source-representation.

Issue:
  -> mangling for id/idrefs

Issue:
  -> should field-access be separate from var-ref?
     this is a little weird:
[field-access field="println"]
  [field-access field="err"]
    [var-ref name="System"]
  [/field-access]
[/field-access]

</pre>
<p><span class="index"><a href="#top">[top]</a></span>

<h3><a name="conclusion">7 - Conclusion</a></h3>

The best is yet to come.  XML tools are improving all the time.

<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="acknowledgments">Acknowledgments</a></h3> 

I thank Miguel Figueroa, Zack Ives, Craig Kaplan, Todd Millstein, Stefan
Bjarni Sigurdsson, for their helpful discussion. Thanks to IBM for
constructing the Jikes compiler framework, and for making it publically
available, and thanks to Mike Ernst for helpful pointers on using it.

<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="javaml-dtd">Appendix 1 - JavaML DTD</a></h3>
<small>
<pre>
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!ENTITY % visibility-attribute "visibility (public|private|protected) #IMPLIED"&gt;
&lt;!ENTITY % kind-attribute "kind (integer|long|real|double) #IMPLIED"&gt;
&lt;!ENTITY % mod-final "final CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-static "static CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-volatile "volatile CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-transient "transient CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-native "native CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-abstract "abstract CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-synchronized "synchronized CDATA #IMPLIED"&gt;

&lt;!ENTITY % expr-elems "send|new|new-array|var-ref|field-access|array-ref|paren|assignment-expr|conditional-expr|binary-expr|unary-expr|cast-expr|literal-number|literal-string|literal-true|literal-false|literal-null|this|super"&gt;

&lt;!ELEMENT java-source-program (package-decl?,import*,(class|interface)+) &gt;
&lt;!ATTLIST java-source-program
    name CDATA #IMPLIED
    version CDATA #IMPLIED&gt;
&lt;!ELEMENT import EMPTY&gt;
&lt;!ATTLIST import
    module CDATA #REQUIRED&gt;
&lt;!ELEMENT class ((implement)*, (constructor|method|field)*) &gt;
&lt;!ATTLIST class
    name CDATA #REQUIRED
    %visibility-attribute;
    %mod-abstract;
    %mod-final;
    %mod-synchronized;
    superclass CDATA "Object"&gt;
&lt;!ELEMENT interface ((extend)*, method*) &gt;
&lt;!ATTLIST interface
    name CDATA #REQUIRED
    %visibility-attribute;&gt;
&lt;!ELEMENT implement EMPTY&gt;
&lt;!ATTLIST implement
    class CDATA #REQUIRED&gt;
&lt;!ELEMENT extend EMPTY&gt;
&lt;!ATTLIST extend
    interface CDATA #REQUIRED&gt;
&lt;!ELEMENT field (type,(%expr-elems;)?)&gt;
&lt;!ATTLIST field
    name CDATA #REQUIRED
    %visibility-attribute;
    %mod-final;
    %mod-static;
    %mod-volatile;
    %mod-transient;&gt;
&lt;!ELEMENT constructor (formal-arguments,throws*,(super-call|this-call)?,statements)&gt;
&lt;!ATTLIST constructor
    name CDATA #REQUIRED
    id ID #REQUIRED
    %visibility-attribute;
    %mod-final;
    %mod-static;
    %mod-synchronized;
    %mod-volatile;
    %mod-transient;
    %mod-native;&gt;
&lt;!ELEMENT method (type,formal-arguments,throws*,statements?)&gt;
&lt;!ATTLIST method 
    name CDATA #REQUIRED
    id ID #REQUIRED
    %visibility-attribute;
    %mod-abstract;
    %mod-final;
    %mod-static;
    %mod-synchronized;
    %mod-volatile;
    %mod-transient;
    %mod-native;&gt;
&lt;!ELEMENT formal-arguments (formal-argument)*&gt;
&lt;!ELEMENT formal-argument (type)&gt;
&lt;!ATTLIST formal-argument
    name CDATA #REQUIRED
    id ID #REQUIRED
    %mod-final;&gt;
&lt;!ELEMENT send (target?,arguments)&gt;
&lt;!ATTLIST send
    message CDATA #REQUIRED&gt;
&lt;!ELEMENT target (%expr-elems;)&gt;
&lt;!ELEMENT return (%expr-elems;)&gt;
&lt;!ELEMENT statements (statements|local-variable|try|throw|if|loop|do-loop|return|continue|break|%expr-elems;)*&gt;
&lt;!ELEMENT throw (%expr-elems;)&gt;
&lt;!ELEMENT throws EMPTY&gt;
&lt;!ATTLIST throws
    exception CDATA #REQUIRED&gt;
&lt;!ELEMENT new (type,arguments)&gt;
&lt;!ELEMENT type EMPTY&gt;
&lt;!ATTLIST type
    primitive CDATA #IMPLIED
    name CDATA #REQUIRED
    dimensions CDATA #IMPLIED&gt;
&lt;!ELEMENT new-array (type,dim-expr*,(%expr-elems;)?)&gt;
&lt;!ATTLIST new-array
    dimensions CDATA #REQUIRED&gt;
&lt;!ELEMENT dim-expr (%expr-elems;)&gt;
&lt;!ELEMENT local-variable (type,(static-initializer|%expr-elems;)?)&gt;
&lt;!ATTLIST local-variable
    name CDATA #REQUIRED
    id ID #REQUIRED
    continuation CDATA #IMPLIED
    %mod-final;&gt;
&lt;!ELEMENT arguments (%expr-elems;)*&gt;
&lt;!ELEMENT literal-string (#PCDATA)&gt;
&lt;!ATTLIST literal-string
    length CDATA #REQUIRED&gt;
&lt;!ELEMENT literal-number EMPTY&gt;
&lt;!ATTLIST literal-number
    value CDATA #REQUIRED
    %kind-attribute;
    base CDATA "10"&gt;
&lt;!ELEMENT var-ref EMPTY&gt;
&lt;!ATTLIST var-ref
    name CDATA #REQUIRED
    idref IDREF #IMPLIED&gt;
&lt;!ELEMENT field-access (%expr-elems;)&gt;
&lt;!ATTLIST field-access
    field CDATA #REQUIRED&gt;
&lt;!ELEMENT var-set EMPTY&gt;
&lt;!ATTLIST var-set
    name CDATA #REQUIRED&gt;
&lt;!ELEMENT field-set (%expr-elems;)&gt;
&lt;!ATTLIST field-set
    field CDATA #REQUIRED&gt;
&lt;!ELEMENT package-decl EMPTY&gt;
&lt;!ATTLIST package-decl
    name CDATA #REQUIRED&gt;
&lt;!ELEMENT assignment-expr (lvalue,(%expr-elems;))&gt;
&lt;!ELEMENT lvalue (var-set|field-set|%expr-elems;)&gt;
&lt;!ELEMENT binary-expr ((%expr-elems;),(%expr-elems;))&gt;
&lt;!ATTLIST binary-expr
    op CDATA #REQUIRED&gt;
&lt;!ELEMENT paren (%expr-elems;)&gt;
&lt;!ELEMENT unary-expr (%expr-elems;)&gt;
&lt;!ATTLIST unary-expr
    op CDATA #REQUIRED
    post (true|false) #IMPLIED&gt;
&lt;!ELEMENT cast-expr (type,(%expr-elems;))&gt;
&lt;!ELEMENT literal-false EMPTY&gt;
&lt;!ELEMENT literal-true EMPTY&gt;
&lt;!ELEMENT literal-null EMPTY&gt;
&lt;!ELEMENT if (test,true-case,false-case?)&gt;
&lt;!ELEMENT test (%expr-elems;)&gt;
&lt;!ELEMENT true-case (statements)&gt;
&lt;!ELEMENT false-case (statements)&gt;
&lt;!ELEMENT array-ref (base,offset)&gt;
&lt;!ELEMENT base (%expr-elems;)&gt;
&lt;!ELEMENT offset (%expr-elems;)&gt;
&lt;!ELEMENT static-initializer (statements)&gt;
&lt;!ELEMENT super-call (arguments)&gt;
&lt;!ELEMENT this-call (arguments)&gt;
&lt;!ELEMENT super EMPTY&gt;
&lt;!ELEMENT this EMPTY&gt;
&lt;!ELEMENT loop (init*,test?,update*,statements?)&gt;
&lt;!ATTLIST loop
    kind (for|while) #IMPLIED&gt;
&lt;!ELEMENT init (local-variable|%expr-elems;)&gt;
&lt;!ELEMENT update (%expr-elems;)&gt;
&lt;!ELEMENT do-loop (statements?,test?)&gt;
&lt;!ELEMENT try (statements,catch*,finally?)&gt;
&lt;!ELEMENT catch (formal-argument,statements?)&gt;
&lt;!ELEMENT finally (statements)&gt;
&lt;!ELEMENT continue EMPTY&gt;
&lt;!ATTLIST continue
    targetname CDATA #IMPLIED&gt;
&lt;!ELEMENT break EMPTY&gt;
&lt;!ATTLIST break
    targetname CDATA #IMPLIED&gt;
&lt;!ELEMENT conditional-expr ((%expr-elems;),(%expr-elems;),(%expr-elems;))&gt;
</pre>
</small>

<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="set.java">Appendix 2a - Extended Example, <strong>Set.java</strong></a></h3>
<small>
<pre>
// Cassowary Incremental Constraint Solver
// (C) 1998, 1999 Greg J. Badros and Alan Borning
//
// Set -- Encapsulate a mathematical "Set" ADT using java's
// hash table.  Just a convenience wrapper of the java.util.Hashtable class.

package EDU.Washington.grad.gjb.cassowary;

import java.util.*;

class Set {
  public Set()
    { hash = new Hashtable(); }

  public Set(int i)
    { hash = new Hashtable(i); }

  public Set(int i, float f)
    { hash = new Hashtable(i,f); }

  public Set(Hashtable h) 
    { hash = h; }

  public boolean containsKey(Object o)
    { return hash.containsKey(o); }

  public boolean insert(Object o)
    { return hash.put(o,o) == null? true: false; }

  public boolean remove(Object o)
    { return hash.remove(o) == null? true: false; }

  public void clear()
    { hash.clear(); }

  public int size()
    { return hash.size(); }

  public boolean isEmpty()
    { return hash.isEmpty(); }

  public Object clone()
    { return new Set((Hashtable) hash.clone()); }

  public Enumeration elements()
    { return hash.elements(); }

  public String toString()
  { 
    StringBuffer bstr = new StringBuffer("{ ");
    Enumeration e = hash.keys();
    if (e.hasMoreElements())
      bstr.append(e.nextElement().toString());
    while ( e.hasMoreElements() ) {
      bstr.append(", " + e.nextElement());
    }
    bstr.append(" }\n");
    return bstr.toString();
  }
  
  private Hashtable hash;
}
</pre>
</small>

<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="set.java.xml">Appendix 2b - Extended Example, <strong>Set.java.xml</strong></a></h3>
<small>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE java-source-program SYSTEM "java-ml.dtd"&gt;

&lt;java-source-program name="Set.java"&gt;
  &lt;package-decl name="EDU.Washington.grad.gjb.cassowary"/&gt;
  &lt;import module="java.util.*"/&gt;
  &lt;class name="Set" superclass="Object"&gt;
    &lt;constructor name="Set" visibility="public" id="ctr-21"&gt;
      &lt;formal-arguments/&gt;
      &lt;statements&gt;
	&lt;assignment-expr&gt;&lt;lvalue&gt;&lt;var-set name="hash"/&gt;&lt;/lvalue&gt;&lt;new&gt;&lt;type name="Hashtable"/&gt;&lt;arguments/&gt;&lt;/new&gt;
	&lt;/assignment-expr&gt;
      &lt;/statements&gt;
    &lt;/constructor&gt;
    &lt;constructor name="Set" visibility="public" id="ctr-30"&gt;
      &lt;formal-arguments&gt;
	&lt;formal-argument name="i" id="frmarg-26"&gt;&lt;type name="int" primitive="true"/&gt;&lt;/formal-argument&gt;
      &lt;/formal-arguments&gt;
      &lt;statements&gt;
	&lt;assignment-expr&gt;&lt;lvalue&gt;&lt;var-set name="hash"/&gt;&lt;/lvalue&gt;&lt;new&gt;&lt;type name="Hashtable"/&gt;&lt;arguments&gt;&lt;var-ref name="i"/&gt;&lt;/arguments&gt;&lt;/new&gt;
	&lt;/assignment-expr&gt;
      &lt;/statements&gt;
    &lt;/constructor&gt;
    &lt;constructor name="Set" visibility="public" id="ctr-43"&gt;
      &lt;formal-arguments&gt;
	&lt;formal-argument name="i" id="frmarg-35"&gt;&lt;type name="int" primitive="true"/&gt;&lt;/formal-argument&gt;
	&lt;formal-argument name="f" id="frmarg-39"&gt;&lt;type name="float" primitive="true"/&gt;&lt;/formal-argument&gt;
      &lt;/formal-arguments&gt;
      &lt;statements&gt;
	&lt;assignment-expr&gt;&lt;lvalue&gt;&lt;var-set name="hash"/&gt;&lt;/lvalue&gt;&lt;new&gt;&lt;type name="Hashtable"/&gt;&lt;arguments&gt;&lt;var-ref name="i"/&gt;&lt;var-ref name="f"/&gt;&lt;/arguments&gt;&lt;/new&gt;
	&lt;/assignment-expr&gt;
      &lt;/statements&gt;
    &lt;/constructor&gt;
    &lt;constructor name="Set" visibility="public" id="ctr-52"&gt;
      &lt;formal-arguments&gt;
	&lt;formal-argument name="h" id="frmarg-48"&gt;&lt;type name="Hashtable"/&gt;&lt;/formal-argument&gt;
      &lt;/formal-arguments&gt;
      &lt;statements&gt;
	&lt;assignment-expr&gt;&lt;lvalue&gt;&lt;var-set name="hash"/&gt;&lt;/lvalue&gt;&lt;var-ref name="h"/&gt;&lt;/assignment-expr&gt;
      &lt;/statements&gt;
    &lt;/constructor&gt;
    &lt;method name="containsKey" visibility="public" id="meth-60"&gt;
      &lt;type name="boolean" primitive="true"/&gt;
      &lt;formal-arguments&gt;
	&lt;formal-argument name="o" id="frmarg-58"&gt;&lt;type name="Object"/&gt;&lt;/formal-argument&gt;
      &lt;/formal-arguments&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;return&gt;&lt;send message="containsKey"&gt;
	      &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
	      &lt;arguments&gt;&lt;var-ref name="o" idref="frmarg-58"/&gt;&lt;/arguments&gt;
	    &lt;/send&gt;
	  &lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="insert" visibility="public" id="meth-69"&gt;
      &lt;type name="boolean" primitive="true"/&gt;
      &lt;formal-arguments&gt;
	&lt;formal-argument name="o" id="frmarg-67"&gt;&lt;type name="Object"/&gt;&lt;/formal-argument&gt;
      &lt;/formal-arguments&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;return&gt;&lt;conditional-expr&gt;&lt;binary-expr op="=="&gt;&lt;send message="put"&gt;
		  &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
		  &lt;arguments&gt;&lt;var-ref name="o" idref="frmarg-67"/&gt;&lt;var-ref name="o" idref="frmarg-67"/&gt;&lt;/arguments&gt;
		&lt;/send&gt;
		&lt;literal-null/&gt;&lt;/binary-expr&gt;&lt;literal-true/&gt;&lt;literal-false/&gt;&lt;/conditional-expr&gt;&lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="remove" visibility="public" id="meth-78"&gt;
      &lt;type name="boolean" primitive="true"/&gt;
      &lt;formal-arguments&gt;
	&lt;formal-argument name="o" id="frmarg-76"&gt;&lt;type name="Object"/&gt;&lt;/formal-argument&gt;
      &lt;/formal-arguments&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;return&gt;&lt;conditional-expr&gt;&lt;binary-expr op="=="&gt;&lt;send message="remove"&gt;
		  &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
		  &lt;arguments&gt;&lt;var-ref name="o" idref="frmarg-76"/&gt;&lt;/arguments&gt;
		&lt;/send&gt;
		&lt;literal-null/&gt;&lt;/binary-expr&gt;&lt;literal-true/&gt;&lt;literal-false/&gt;&lt;/conditional-expr&gt;&lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="clear" visibility="public" id="meth-82"&gt;
      &lt;type name="void" primitive="true"/&gt;
      &lt;formal-arguments/&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;send message="clear"&gt;
	    &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
	    &lt;arguments/&gt;
	  &lt;/send&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="size" visibility="public" id="meth-88"&gt;
      &lt;type name="int" primitive="true"/&gt;
      &lt;formal-arguments/&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;return&gt;&lt;send message="size"&gt;
	      &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
	      &lt;arguments/&gt;
	    &lt;/send&gt;
	  &lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="isEmpty" visibility="public" id="meth-93"&gt;
      &lt;type name="boolean" primitive="true"/&gt;
      &lt;formal-arguments/&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;return&gt;&lt;send message="isEmpty"&gt;
	      &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
	      &lt;arguments/&gt;
	    &lt;/send&gt;
	  &lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="clone" visibility="public" id="meth-98"&gt;
      &lt;type name="Object"/&gt;
      &lt;formal-arguments/&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;return&gt;&lt;new&gt;&lt;type name="Set"/&gt;&lt;arguments&gt;&lt;cast-expr&gt;&lt;type name="Hashtable"/&gt;&lt;send message="clone"&gt;
		    &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
		    &lt;arguments/&gt;
		  &lt;/send&gt;
		&lt;/cast-expr&gt;&lt;/arguments&gt;&lt;/new&gt;
	  &lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="elements" visibility="public" id="meth-103"&gt;
      &lt;type name="Enumeration"/&gt;
      &lt;formal-arguments/&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;return&gt;&lt;send message="elements"&gt;
	      &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
	      &lt;arguments/&gt;
	    &lt;/send&gt;
	  &lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="toString" visibility="public" id="meth-108"&gt;
      &lt;type name="String"/&gt;
      &lt;formal-arguments/&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;local-variable name="bstr" id="locvar-216"&gt;&lt;type name="StringBuffer"/&gt;&lt;new&gt;&lt;type name="StringBuffer"/&gt;&lt;arguments&gt;&lt;literal-string length="4"&gt;{ &lt;/literal-string&gt;&lt;/arguments&gt;&lt;/new&gt;
	  &lt;/local-variable&gt;
	  &lt;local-variable name="e" id="locvar-223"&gt;&lt;type name="Enumeration"/&gt;&lt;send message="keys"&gt;
	      &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
	      &lt;arguments/&gt;
	    &lt;/send&gt;
	  &lt;/local-variable&gt;
	  &lt;if&gt;&lt;test&gt;&lt;send message="hasMoreElements"&gt;
		&lt;target&gt;&lt;var-ref name="e" idref="locvar-223"/&gt;&lt;/target&gt;
		&lt;arguments/&gt;
	      &lt;/send&gt;
	    &lt;/test&gt;
	    &lt;true-case&gt;&lt;statements&gt;
		&lt;send message="append"&gt;
		  &lt;target&gt;&lt;var-ref name="bstr"/&gt;&lt;/target&gt;
		  &lt;arguments&gt;&lt;send message="toString"&gt;
		      &lt;target&gt;&lt;send message="nextElement"&gt;
			  &lt;target&gt;&lt;var-ref name="e"/&gt;&lt;/target&gt;
			  &lt;arguments/&gt;
			&lt;/send&gt;
		      &lt;/target&gt;
		      &lt;arguments/&gt;
		    &lt;/send&gt;
		  &lt;/arguments&gt;
		&lt;/send&gt;
	      &lt;/statements&gt;
	    &lt;/true-case&gt;
	  &lt;/if&gt;
	  &lt;statements&gt;
	    &lt;loop kind="while"&gt;&lt;test&gt;&lt;send message="hasMoreElements"&gt;
		  &lt;target&gt;&lt;var-ref name="e"/&gt;&lt;/target&gt;
		  &lt;arguments/&gt;
		&lt;/send&gt;
	      &lt;/test&gt;&lt;statements&gt;
		&lt;send message="append"&gt;
		  &lt;target&gt;&lt;var-ref name="bstr"/&gt;&lt;/target&gt;
		  &lt;arguments&gt;&lt;binary-expr op="+"&gt;&lt;literal-string length="4"&gt;, &lt;/literal-string&gt;&lt;send message="nextElement"&gt;
			&lt;target&gt;&lt;var-ref name="e"/&gt;&lt;/target&gt;
			&lt;arguments/&gt;
		      &lt;/send&gt;
		    &lt;/binary-expr&gt;&lt;/arguments&gt;
		&lt;/send&gt;
	      &lt;/statements&gt;
	    &lt;/loop&gt;
	  &lt;/statements&gt;
	  &lt;send message="append"&gt;
	    &lt;target&gt;&lt;var-ref name="bstr" idref="locvar-216"/&gt;&lt;/target&gt;
	    &lt;arguments&gt;&lt;literal-string length="6"&gt; }\n&lt;/literal-string&gt;&lt;/arguments&gt;
	  &lt;/send&gt;
	  &lt;return&gt;&lt;send message="toString"&gt;
	      &lt;target&gt;&lt;var-ref name="bstr" idref="locvar-216"/&gt;&lt;/target&gt;
	      &lt;arguments/&gt;
	    &lt;/send&gt;
	  &lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;field name="hash" visibility="private"&gt;&lt;type name="Hashtable"/&gt;&lt;/field&gt;
  &lt;/class&gt;
&lt;/java-source-program&gt;
</pre>
</small>


<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="references">References</a></h3>

<pre>
Java

JavaNutShell

http://www.w3.org/TR/xslt

http://www.w3.org/TR/WD-xsl/

http://www.w3.org/XML/1999/XML-in-10-points

http://www.w3.org/TR/xpath

http://www.w3.org/TR/xmlschema-1/

http://www.w3.org/TR/xmlschema-2/

Smalltalk

C++

Modula-2

XML

EvilMacros

Framework for Preprocessor-aware C Source Code Analyses
</pre>

<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="vitae">Vitae</a></h3>

<IMG ALT="Greg J. Badros" SRC="./gjb-face-transp.gif" width=75><br>

<strong><a href="http://www.cs.washington.edu/homes/gjb">Greg J. 
Badros</a></strong> is a final-year Ph.D. candidate at the
<a href="http://www.cs.washington.edu">University of Washington</a>
in Seattle, Washington where he earned his
M.Sc. degree in 1998.  He graduated <i>magna cum laude</i> with a
B.S. degree in <a href="http://www.math.duke.edu">Mathematics</a> and 
<a href="http://www.cs.duke.edu">Computer Science</a> from
<a href="http://www.duke.edu">Duke University</a> in
1995.  He is the primary author of the <a
href="http://scwm.mit.edu">Scheme Constraints Window Manager</a> and the
<a href="http://www.cs.washington.edu/research/constraints/cassowary/">Cassowary
Constraint Solving Toolkit</a>.  His research interests include
constraint technology, software engineering, languages, and the
internet.

<hr>
<a href="#introduction">Introduction</a> &nbsp;
<a href="#background">Background</a> &nbsp;
<a href="#javaml">JavaML</a>  &nbsp;
<a href="#leveraging-xml">Leveraging XML</a> <br>
<a href="#related-work">Related work</a>  &nbsp;
<a href="#future-work">Future work</a>  &nbsp;
<a href="#conclusion">Conclusion</a>  &nbsp; 
<a href="#acknowledgments">Acknowledgments</a>  <br>
<a href="#javaml-dtd">Appendix 1 - JavaML DTD</a> 
<a href="#set.java">Appendix 2a - Extended Example,
      <strong>Set.java</strong></a>  &nbsp;
<a href="#set.java.xml">Appendix 2b - Extended Example,
      <strong>Set.java.xml</strong></a>  <br>
<a href="#references">References</a>  &nbsp;
<a href="#vitae">Vitae</a> 

<p><span class="index"><a href="#top">[top]</a></span>

<hr>
<address>
      <a href="http://www.cs.washington.edu/homes/gjb">Greg J. Badros</a> / 
      <a href="http://www.cs.washington.edu">U Washington Computer Science and Engineering</a> /
      <a href="mailto:gjb@cs.washington.edu">gjb@cs.washington.edu</a></address>
</body>
</html>
