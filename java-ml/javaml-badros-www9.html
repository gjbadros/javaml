<!--$Id$-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>
JavaML: A Markup Language for Java Source, by Greg J. Badros
</title>
<!--
  Title 
  Authors 
  Affiliations 
  Abstract 
  Keywords 
  Main body of text 
  Acknowledgements 
  Appendix 
  References 
  Vitae 
-->
<STYLE TYPE="text/css">
<!--
BODY { BACKGROUND-COLOR: #ffffff; FONT-FAMILY: arial, times new roman, sans-serif; }
A:link, A:visited, A:active { TEXT-DECORATION: none; FONT-WEIGHT: bold; COLOR: #0000FF}

H1, H2 { TEXT-ALIGN: center; FONT-WEIGHT: bold; }
H3, H4, H5 { TEXT-ALIGN: left; FONT-WEIGHT: bold; }
H6 { TEXT-ALIGN: center; FONT-WEIGHT: bold; FONT-SIZE: small; }
H6.CAPTION { TEXT-ALIGN: center; FONT-WEIGHT: bold; FONT-SIZE: small; FONT-STYLE: italic; }

P { TEXT-INDENT: 1em; }
P.CODE { TEXT-INDENT: 0; COLOR: #FF0000; }

UL, OL, DL { MARGIN-LEFT: 2em; FONT-SIZE: medium; }
UL { list-style: square; }
LI { FONT-SIZE: small; FONT-WEIGHT: bold; }
UL EM, OL EM { FONT-WEIGHT: bold; }
CODE, CITE { FONT-WEIGHT: bold; }
DD { MARGIN-TOP: 5em; margin-left: 5em }

BLOCKQUOTE { MARGIN-LEFT: 1em; MARGIN-RIGHT: 1em }
IMG { VERTICAL-ALIGN: top; ALIGN: center; }
SUP { COLOR: #0000FF; FONT-SIZE: small; }

-->
</STYLE>
</head>
<body>
<h2>
<a name="top">JavaML: A Markup Language for Java Source Code</a>
</h2>
<h6><a href="http://www.cs.washington.edu/homes/gjb">Greg J. Badros</a><br>
<a href="http://www.cs.washington.edu">Department of Computer Science and Engineering</a><br>
<a href="http://www.washington.edu">University of Washington</a></h6>

<hr>
<a href="#introduction">Introduction</a> &nbsp;
<a href="#background">Background</a> &nbsp;
<a href="#javaml">JavaML</a>  &nbsp;
<a href="#leveraging-xml">Leveraging XML</a> <br>
<a href="#related-work">Related work</a>  &nbsp;
<a href="#future-work">Future work</a>  &nbsp;
<a href="#conclusion">Conclusion</a>  &nbsp; 
<a href="#acknowledgments">Acknowledgments</a>  <br>
<a href="#javaml-dtd">Appendix 1 - JavaML DTD</a> &nbsp;
<a href="#set.java">Appendix 2a</a>, <a href="#set.java.xml">2b</a> <a href="#set.java">Extended Example </a>  &nbsp;
<a href="#references">References</a>  &nbsp;
<a href="#vitae">Vitae</a> 

<hr>

<h3><a name="abstract">Abstract</a></h3>

      The typical plain-text representation of source code is convenient
      for programmers but requires parsing to uncover the deep structure
      of the program.  While sophisticated software tools parse source
      code to gain access to the program's structure, many lightweight
      programming aids such as <code>grep</code> rely instead on only the
      lexical structure of source code.  I describe a new XML
      application that provides an alternative representation
      of Java source code. This XML-based representation, called JavaML,
      is more natural for tools and permits easy specification of
      numerous software-engineering analysis by leveraging the abundance
      of XML tools and techniques.  A robust converter built with the IBM
      Jikes Java compiler framework translates from the classical Java
      source code representation to JavaML.

<h3><a name="keywords">Keywords</a></h3>

Java, source-code, SGML, XML, abstract syntax tree, AST, parsing,
analysis, software-engineering, Jikes

<h3><a name="introduction">1 - Introduction</a></h3>

Since the first computer programming languages, programmers have used 
a text representation
as the medium for encoding software structure and
computation.  Over the years, techniques have been developed that
largely mechanize the front-end of compilers which perform the lexical
analysis and parsing necessary to uncover the structure of programming
language constructs represented as plain text.  Tools such as <code>Lex/Flex</code>
and Yacc/Bison <cite>[<a href="#REF-LexYacc">LexYacc</a>]</cite> automate these uninteresting tasks
by using well-founded concepts of regular expressions and
grammars. Regular expressions describe how individual characters combine
to form tokens, and the grammar enumerates how higher-level constructs
are composed recursively of other constructs and primitive tokens.  Together, these
procedures convert from a sequence of characters into a data structure
called an <em>abstract syntax tree</em> (AST) that more directly
reflects the structure of the source program.

<p>

The textual representation of source code has several nice properties.
It can be concise and is similar to natural languages, often making
it easy to read.  Text is a universal data format thus making source
code easy to exchange and manipulate using a wide variety of tools
including text editors, version control systems, and command pipeline
utilities such as <code>grep</code>, <code>awk</code>, and
<code>wc</code>.

<p>

Nevertheless, the <em>classical source representation</em> has numerous 
problems.  The syntax of popular contemporary
languages such as C++ and Perl push the limits of parsing capabilities
(witness the <code>typename</code> keyword in C++ that is necessary to
resolve an ambiguity in template-based code).  Constructing a front-end
for such languages is difficult despite the support from 
tools.  Perhaps more disconcerting is that evolving the syntax of the
language often requires manipulating a fragile grammar.  This limitation
complicates handling an evolving language.

<p>

Another problem with the classical representation is that parsing is not very
robust.  A small change in the source code can have a dramatic effect on
the resulting AST and, thus, the semantics of the computation.  For
example, a single extraneous semicolon can change a looping block into
an ordinary one and result in an infinite loop:

<code>
<pre>
  int i = 10;
  while (i &gt; 0); {
    /* ... */ --i;
  }
</pre>
</code>

Other, more-concise languages suffer from far more dangerous semantic
changes stemming from small syntactic errors (the Perl language is the infamous
example).

 <h4><a name="tools">1.1 - Text representation and software tools</a></h4>

Probably the most significant limitation of the classical source representation
is that the structure
of the program is made manifest only after parsing.  This shortcoming
forces language-specific parsing functionality to be duplicated in every
tool that needs to reason about the program beyond its lexical nature.
Compilers, by necessity, must work with the AST, but numerous other
software-engineering tools would perform better with access to the
structured representation of the source code.  Unfortunately, many
software-engineering tools do not embed a parser and thus are limited to
lexical tasks.

<p>

There are several reasons why tool developers often avoid embedding a parser in
tools.  As mentioned previously, building a complete front-end is
challenging for syntactically-complex languages.  Although re-using
existing infrastructure (e.g., the grammar definition) simplifies
implementation, working with the resulting AST is not always intuitive.  An
AST typically reflects quirky artifacts of the grammar rather than
representing the programming-level constructs directly.  Additionally,
embedding the front-end of a compiler may be deemed overkill when targeting
a simple analysis that can do "good enough" with lexical information.

<p>

Other complications arise if a transformation of the source code is
desired: a change in the AST must ultimately be reflected in the classical
source representation
because that is the primary long-term representation.  Recreating a text
representation from an AST is most
straightforwardly done using an unparsing approach that can create
undesired lexical side effects (e.g., changes in indentation or
whitespace) that confuse the other lexical tools that a developer
relies upon (e.g., a version control system that is unable to
disambiguate between a meaningful change and a gratuitous one effected
unintentionally).  Finally, using a parser in a tool necessarily targets
that tool to a specific language, thus reducing its applicability and
generality.  Worse, because there is no standard structured external
representation of a source program, supporting inter-operability of
independent tools even targeting the same programming language is
very difficult.

<p>

The end result of these complications is that developers often use
simple, lexically-oriented tools such as <code>grep</code> or search and
replace within an editor.  This approach sacrifices accuracy:
imagine wanting to rename a local variable from <code>result</code> to
<code>answer</code>.  With simple search-and-replace, all occurrences of
the word will be changed, even if they refer to characters inside
comments, literal strings, or an unrelated instance field.

<p>

An alternate route taken by some developers is that they rely instead on
a fixed set of tools provided within an integrated development
environment (IDE) that has access to the structure of their source
program via an integrated language-specific parser.  This approach
sacrifices flexibility.  IDEs generally provide only a limited set of
capabilities and extending those is hard.  Additionally, analyses and
transformation on source code are often hard to automate or perform in
batch using existing interactive environments.  Some more advanced
IDEs, such as IBM VisualAge for C++ <cite>[<a href="#REF-Montana">Montana</a>]</cite>, expose an
application programming interface to the representation of the program.
Although an improvement, this technique still suffers from an inability
to separate simple tools from a complex environment and additionally
creates a dependency on proprietary technology that may be undesirable.

 <h4><a name="solution">1.2 - A solution</a></h4>

One of the fundamental problems underlying the above difficulties is the
lack of a canonical representation of the structure of source code.
We need a universal format for directly representing the structure that
software tools can easily analyze and manipulate.  The key
observation is that XML, the eXtensible Markup Language, provides
exactly this capability and can provide an incredibly empowering 
complementary representation for source code.

<p>

In this paper, I introduce the Java Markup Language, JavaML &#151; an XML
application for describing Java source programs.  The JavaML document
type definition (DTD) specifies the various elements of a valid JavaML
document and how they may be combined.
There is a natural correspondence between the elements and
their attributes and the programming language constructs they model.
The structure of the source program is reflected in the nesting of
elements in the JavaML document.  With this representation, we can then
leverage the wealth of tools for manipulating and querying XML and SGML
documents to provide a rich infrastructure for software engineering
transformations and analyses on Java source code.  

<p>

JavaML is well-suited to be used as a canonical representation of Java
source code for tools.  It shares most of the strengths of the classical
representation and overcomes
many weaknesses.  The <a href="#background">next section</a> describes
relevant features of Java and XML and <a href="#javaml">
section 3</a> details the markup language and the implementation of a
converter from the classical representation to JavaML.  <a href="#leveraging-xml">Section
4</a> gives numerous examples of how existing XML and SGML tools can be
exploited to perform source code analyses and transformations on the
richer representation provided by JavaML.  Sections <a href="#related-work">5</a>
and <a href="#future-work">6</a> describe others' <a href="#related-work">related
work</a> and suggest avenues for exciting <a href="#future-work">future work</a>, and
<a href="#conclusion">section 7</a> concludes.

<p>

The full document type definition (DTD) for JavaML appears in <a
href="#javaml-dtd">Appendix 1</a> and an example of converted source code
is given in Appendices <a href="#set.java">2a</a> and <a
href="#set.java.xml">2b</a>.


<p><span class="index"><a href="#top">[top]</a></span>

<h3><a name="background">2 - Background</a></h3>

The Java Markup Language is influenced by and benefits from numerous 
features of the two technologies it builds a bridge between: Java and XML.

 <h4><a name="java">2.1 - Java</a></h4>

    Although the XML-based representation of programming language
    constructs is language independent and could be applied to many
    conventional languages, Java is an excellent candidate for 
    experimenting with these ideas and techniques.

<p>

    Java is a popular object-oriented programming language developed by
    Sun Microsystems in the mid-1990s.  It features a
    platform-independent execution model based on the Java Virtual
    Machine (JVM) and owes its quick acceptance to its use as a
    programming language for World Wide Web applications.  Java combines
    a simple object model reminiscent of Smalltalk with Algol block
    structure, a C++-like syntax, a static type system, and a package
    system inspired by Modula-2. <cite>[<a href="#REF-Java">Java</a>,<a href="#REF-JavaNutshell">JavaNutshell</a>]</cite>

<p>

   As in most other object-oriented (OO) languages, the primary unit of
   decomposition in Java is a <em>class</em> which specifies the behaviour of a
   set of objects.  Each class can define several <em>methods</em>, or
   behaviours, similar to functions or procedures. A class can also
   define <em>fields</em>, or state variables, that are associated with
   "instances" of the class called <em>objects</em>. Classes can inherit
   behaviour and state from <em>superclasses</em>, thus forming a hierarchy of
   inter-related classes that permits factoring related code into
   classes at the top of the hierarchy, and encourages re-use.
   Behaviours are invoked by sending a <em>message</em> to a target receiver
   object that is a request to execute a method defined for that class.
   Choosing what method to execute in response to a message is called
   <em>dynamic dispatch</em> and is based on the run-time class of the object
   receiving the message.  For example, an instance of the <code>ColoredBall</code>
   class may respond to the <code>draw</code> message differently than an instance
   of a <code>Ball</code> class.  This ability to behave differently upon receipt
   of the same message is largely responsible
   for the extensibility benefits touted by the OO community.
    
<p>
      

<!-- Java also is free from "parsing state" like "public:" and "private:" in c++ -->

   Java is being widely used both in industry and in education, and it
   remains popular as a programming language on the web.  Unlike C++, a
   Java class definition exists in a single, self-contained file.  There
   are no separate header files and implementation files, and Java is
   largely free from order-dependencies of definitions.  A method body
   (when present) is always defined immediately following the
   declaration of the method signature.   Additionally,
   Java lacks an integrated preprocessor.  These features combine to
   make Java source programs syntactically very clean, and make Java an
   ideal language for representing using XML.

  <h4><a name="xml">2.2 - XML: Extensible Markup Language</a></h4>

XML is a standardized eXtensible Markup Language <cite>[<a href="#REF-XML">XML</a>]</cite> 
that is a subset of
SGML, the standard Generalized Markup Language <cite>[<a href="#REF-SGML">SGML</a>]</cite>.  The World Wide Web
Consortium (W3C) designed XML to be lightweight and simple, while
retaining compatibility with SGML.  Although HTML (HyperText Markup
Language) is currently the standard language, the W3C is positioning XML
to be its replacement.  While HTML permits authors to use only a
pre-determined fixed set of tags in marking up their document, XML
allows easy specification of user-defined markup tags adapted to the
document and data at hand. <cite>[<a href="#REF-LaTeXWeb">LaTeXWeb</a>,<a href="#REF-XML-Handbook">XML-Handbook</a>]</cite>

<p>

An XML document consists simply of text marked up with tags enclosed in
angle braces.  A simple example is:

<code>
<pre>
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE email SYSTEM "email.dtd"&gt;
&lt;email&gt;
  &lt;head&gt;
    &lt;to&gt;Mom&lt;/to&gt;
    &lt;from&gt;Greg&lt;/from&gt;
    &lt;subject&gt;My trip&lt;/subject&gt;
  &lt;/head&gt;
  &lt;body encoding="ascii"&gt;The weather is terrific!&lt;/body&gt;
&lt;/email&gt;
</pre>
</code>

The <code>&lt;email&gt;</code> is an open tag for the <code>email</code>
element.  The <code>&lt;/email&gt;</code> at the end of the example is the
corresponding close tag.  Text and other nested tags can appear between
the open and close constructs.  In the above, the <code>email</code>
element contains two immediate children elements: a <code>head</code> and a
<code>body</code>.  Additionally, an XML open tag can associate
attribute/value pairs with an element.  For example, the <code>body</code> element
above has the value <code>ascii</code> for its <code>encoding</code>
attribute.  For an XML document to be <em>well-formed</em>, the
document must simply conform to the numerous syntactic rules required of
XML documents (e.g., tags must be balanced and properly nested,
attribute values must be of the proper form and enclosed in quotes,
etc.).

A more stringent characterization of an XML document is
<em>validity</em>.  An XML document is valid if and only if it both is
well-formed and adheres to its specified <em>document type
definition</em>, or <em>DTD</em>.  A document type definition is a
formal description of the grammar of the specific language to be used by
a class of XML documents.  A DTD defines all the permitted element
names and describes the attributes that each kind of element may
possess. It also restricts the structure of the nesting within a valid
XML document.  The preceding XML example is valid with respect to the
following DTD:

<code>
<pre>
&lt;!-- email DTD --&gt;
&lt;!ELEMENT email (head,body)&gt;
&lt;!ELEMENT head (to,from,subject?)&gt;
&lt;!ELEMENT to (#PCDATA)&gt;
&lt;!ELEMENT from (#PCDATA)&gt;
&lt;!ELEMENT subject (#PCDATA)&gt;
&lt;!ELEMENT body (#PCDATA)&gt;
&lt;!ATTLIST body
    encoding (ascii|mime) #REQUIRED&gt;
    encrypted (yes|no) #IMPLIED&gt;
</pre>
</code>

According to this DTD, there are six element types. The
<code>email</code> element must contain exactly one <code>head</code>
followed by exactly one <code>body</code> element.  The
<code>head</code>, in turn, must contain <code>to</code> and
<code>from</code> elements, in that order, followed by an optional
<code>subject</code> element.  Each of those elements may contain text 
(also know as <em>parsed
character data</em> or <code>PCDATA</code>).  The single <code>ATTLIST</code>
declaration in the DTD specifies that the <code>body</code> element
<em>must</em> specify a value of either <code>ascii</code> or
<code>mime</code> for the <code>encoding</code> attribute, and
<em>may</em> specify a value for the <code>encrypted</code> attribute.
An XML document that is declared to adhere to this DTD is not valid if
any of the above criteria are not met.  For example, if the
<code>to</code> element is missing from an <code>email</code> document,
that document is not valid, though it may still be well-formed.

<p>

When modeling data in XML, a primary design decision is choosing whether
to nest elements or to use attributes.  In the above example, we could
have folded all of the information contained in the <code>head</code>
into attributes of the <code>email</code> element if we chose.  There
are several important differences between using attributes and nesting
elements:

<ul>

<li> Attributes/value pairs are unordered, while nested children have a
specific order;

<li> values for attributes may contain only character data, and may not
include other markup, while nested children can arbitrarily nest
further; and

<li> only one value for an attribute can be given, while multiple
elements of the same class can be included by a parent element (e.g., we
could have multiple <code>to</code> elements contained by the
<code>head</code> with only a simple change to the DTD).

</ul>

Although the above distinctions sometimes mandate using one technique or
the other, the decision is often initially a matter of taste.  However,
later experiences using the resulting documents may suggest
revisiting the decision in order to facilitate or simplify
some useful manipulation of the document.

<p>

Another useful data modeling feature of XML is the ability to attach
unique identifiers to elements via an <code>ID</code> attribute.  These
elements can then be later referred to by <code>IDREF</code> attributes
of other elements.  A well-formed XML document must have every
<code>IDREF</code> name be an <code>ID</code> given in the document.


<p>

XML, in part due to its SGML heritage, is very well supported by tools
such as Emacs editing modes, structure-based editors, DTD parsers and
editors, validation utilities, querying systems, transformation and
style languages, and many more tools.  Numerous other W3C recommendations
inter-relate to XML including Cascading Style Sheets
<cite>[<a href="#REF-CSS2">CSS2</a>]</cite>, XSL (Extensible Stylesheet Language)
<cite>[<a href="#REF-XSL">XSL</a>]</cite> and XSLT (XSL for Transformations)
<cite>[<a href="#REF-XSLT">XSLT</a>]</cite>, XPath <cite>[<a href="#REF-XPath">XPath</a>]</cite>, and DOM (Document
Object Model) <cite>[<a href="#REF-DOM">DOM</a>]</cite>.

<p><span class="index"><a href="#top">[top]</a>

<h3><a name="javaml">3 - JavaML: The Java Markup Language</a></h3>

The Java Markup Language provides a complete self-describing
representation of Java source code.  Unlike the conventional
character-based representation of programs, JavaML reflects the
structure of the software artifact directly in the nesting of elements
in the XML-based syntax.  Because XML is a text-based representation, many
of the advantages of the classical source representation remain. Because
JavaML is an XML application, JavaML is easy to parse, and
all existing tools for working with XML can be applied to Java source
code in its JavaML representation.  JavaML tools can leverage the
existing infrastructure and exploit the canonical representation to
improve inter-operability among tool sets.


<h4><a name="approaches">3.1 - Possible approaches</a></h4>

Although the basic approach of using an XML application to model source
code is fairly straightforward, there is a large design space for
possible markup languages.  The most obvious possibility is to simply use
XML as a textual dump format of a typical abstract syntax tree derived
from parsing source code.  Consider the simple Java program:

<code>
<pre>
import java.applet.*;
import java.awt.*;

public class FirstApplet extends Applet {
  public void paint(Graphics g) {
    g.drawString("Hello World", 25, 50);
  }
}
</pre>
</code>

Performing the obvious (but very unsatisfying) translation from the AST
of the above might result in the below XML <em>for just the first line of code</em>:

<code>
<pre>
&lt;compilation-unit&gt;
 &lt;ImportDeclarationsopt&gt;
  &lt;ImportDeclarations&gt;
   &lt;ImportDeclaration&gt;
    &lt;TypeImportOnDemandDeclaration&gt;
      import
      &lt;Name&gt;
       &lt;QualifiedName&gt;
        &lt;Name&gt;
         &lt;SimpleName&gt;java&lt;/SimpleName&gt;
        &lt;/Name&gt;
        .
        &lt;Name&gt;
         &lt;SimpleName&gt;applet&lt;/SimpleName&gt;
        &lt;/Name&gt;
       &lt;QualifiedName&gt;
      &lt;/Name&gt;
       . * ;
    &lt;/TypeImportOnDemandDeclaration&gt;
   &lt;/ImportDeclaration&gt;
  &lt;/ImportDeclarations&gt;
 &lt;/ImportDeclarationsopt&gt;
...
&lt;compilation-unit&gt;
</pre>
</code>

Certainly this translation is far from ideal:  it is unacceptably verbose, exposes
numerous uninteresting details of the underlying grammar that was used to do the
initial parse from the classical source representation and would be difficult to work with because
of the excessive number of nodes.

<p>

An alternate possibility is to literally mark-up the Java source program
without changing the text of the program (i.e., only adding tags).  This approach might
convert the <code>FirstApplet.java</code> implementation to:

<code>
<pre>
&lt;java-source-program&gt;
&lt;import-declaration&gt;import java.applet.*;&lt;/import-declaration&gt;
&lt;import-declaration&gt;import java.awt.*;&lt;/import-declaration&gt;

&lt;class-declaration&gt;
&lt;modifiers&gt;public&lt;/modifiers&gt; class 
   &lt;class-name&gt;FirstApplet&lt;/class-name&gt; 
     extends &lt;superclass&gt;Applet&lt;/superclass&gt; {
 &lt;method-definition&gt;
  &lt;modifiers&gt;public&lt;/modifiers&gt; &lt;return-type&gt;void&lt;/return-type&gt; 
    &lt;method-name&gt;paint&lt;/method-name&gt;
      (&lt;formal-arguments&gt;&lt;type&gt;Graphics&lt;/type&gt; 
             &lt;name&gt;g&lt;/name&gt;&lt;/formal-arguments&gt;) 
    &lt;statements&gt;{
    g.drawString("Hello World", 25, 50);
  } &lt;/statements&gt;
 &lt;/method-definition&gt;
}
&lt;/class-declaration&gt;
&lt;/java-source-program&gt;
</pre>
</code>

This format is a huge step towards a more useful markup language.
We have definitely added value to the source code
and it is trivial to convert back to the classical representation: we simply
remove all tags and leave the content of the elements behind (this
removal of markup is
exactly what the <code>stripsgml</code> <cite>[<a href="#REF-perlSGML">perlSGML</a>]</cite> utility
does).  Although this representation seems useful for many tasks, it still
has some problems.  First, many of the details of the code are included
in the textual content of elements.  If we want to determine what
packages are being imported, our XML query would need to lexically
analyze the content of the import-declaration elements.  Such analysis is
inconvenient and does not take advantage of the capabilities that XML
provides.  Perhaps more significantly, the above XML representation
retains artifacts from the classical source code that another representation might permit
us to abstract away from and free ourselves of those syntactic burdens
altogether.

<h4><a name="chosen-representation">3.2 - The chosen representation</a></h4>

The prototype JavaML representation I have chosen aims to model the
programming language constructs of Java (and, indeed, similar
object-oriented programming languages) independently of the specific
syntax of the language.  One can easily imagine a SmalltalkML that would 
be very similar, and even an OOML that could be converted into 
both classical Java source code or Smalltalk file-out format.  With this goal in mind,
JavaML was designed from first principles of the constructs and then
iteratively refined to improve the usefulness
and readability of the resulting markup language.  

<p>

JavaML is defined by the document type definition (DTD) in
<a href="javaml.dtd">Appendix 1</a>, but is best illustrated by example. 
For the <code>FirstApplet.java</code> source code listed above, we represent 
the program in JavaML as:

<code>
<pre>
   1  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   2  &lt;!DOCTYPE java-source-program SYSTEM "java-ml.dtd"&gt;
   3  
   4  &lt;java-source-program name="FirstApplet.java"&gt;
   5    &lt;import module="java.applet.*"/&gt;
   6    &lt;import module="java.awt.*"/&gt;
   7    &lt;class name="FirstApplet" visibility="public" superclass="Applet"&gt;
   8      &lt;method name="paint" visibility="public" id="meth-15"&gt;
   9        &lt;type name="void" primitive="true"/&gt;
  10        &lt;formal-arguments&gt;
  11  	&lt;formal-argument name="g" id="frmarg-13"&gt;
  12               &lt;type name="Graphics"/&gt;&lt;/formal-argument&gt;
  13        &lt;/formal-arguments&gt;
  14        &lt;statements&gt;
  15  	&lt;statements&gt;
  16  	  &lt;send message="drawString"&gt;
  17  	    &lt;target&gt;&lt;var-ref name="g" idref="frmarg-13"/&gt;&lt;/target&gt;
  18  	    &lt;arguments&gt;
  19                &lt;literal-string length="11"&gt;Hello World&lt;/literal-string&gt;
  20                &lt;literal-number kind="integer" value="25"/&gt;
  21                &lt;literal-number kind="integer" value="50"/&gt;
  22              &lt;/arguments&gt;
  23  	  &lt;/send&gt;
  24  	&lt;/statements&gt;
  25        &lt;/statements&gt;
  26      &lt;/method&gt;
  27    &lt;/class&gt;
  28  &lt;/java-source-program&gt;
</pre>
</code>

In the above document, concepts such as methods, superclasses, message sends, and
literal numbers are all directly represented in the elements and
attributes of the representation.  The representation reflects the 
structure of the programming language in the nesting of the elements.  
For example, the literal
string "Hello World" is a part of the message send, thus the
<code>literal-string</code> element is nested inside the
<code>send</code> element.  This nesting is even more apparent
when presented visually as in <a href="#fig1">figure 1</a>. See Appendices <a
href="#set.java">2a</a> and <a href="#set.java.xml">2b</a> for an
example of a more complex converted program.

<p class="caption">
<a name="fig1"><IMG ALT="Tree view of FirstApplet's JavaML representation." SRC="./diff-tree-view.gif"></a>
<strong>Figure 1</strong> &#151; A fully-expanded tree view of the JavaML representation 
of the <code>FirstApplet</code> example as viewed by IBM's <code>xmldiff</code> utility <cite>[XMLDiffMerge]</cite>.</p>


<h4><a name="design-decisions">3.3 - Design decisions</a></h4>

JavaML provides more than just the structure of the source program,
though.  In the preceding example, notice the use of the formal-argument
<code>g</code> in line 17 as the target of the message send.  The
<code>idref</code> attribute of that <code>var-ref</code> tag points
back at the referenced <code>formal-argument</code> element (through its
<code>id</code> attribute).  (The <code>id</code> value chosen for
a to-be-referenced element must be unique within a document so each is branded with
integers to keep the values distinct.)  This linking is standard XML, thus XML
tools are able to trace from a variable use to its definition to, e.g.,
obtain the type of the variable.  Similar linking is done for local
(block-declared) variables.  In JavaML, variable references are easy to
locate because of their distinguishing <code>var-ref</code> tag.
Additionally, they are disambiguated from an assignment to a variable
which is converted into a <code>var-set</code> tag.

<p>

Throughout JavaML, attributes of elements are used whenever the
structure of the value can never be more complex than a simple text string.
Attributes are used for modifiers such as <code>synchronized</code> and
<code>final</code> and for visibility settings such as
<code>public</code> or <code>private</code>.  Attributes are not used
for properties such as types because types have some structure: a type
can consist of a base name and a number of dimensions, and could also
reference the definition of the class that implements the type, if
desired.  If, say, a return type were just the value of an attribute on
the method element, the end user would unacceptably have to do string
processing on the attribute's value "<code>int[][]</code>" to determine that the base
type of that two-dimensional array was the primitive type
<code>int</code>.

<p>

JavaML generalizes related concepts to simplify some analyses
but also preserves distinctions that may be needed for other tasks.
For example, <code>45</code> and <code>1.9</code> are represented as:
<code>&lt;literal-number kind="integer" value="45"&gt;</code> and
<code>&lt;literal-number kind="float" value="1.9"&gt;</code>,
respectively.  An alternate possible markup is:
<code>&lt;literal-integer value="45"&gt;</code> and
<code>&lt;literal-float value="1.9"&gt;</code> but using separate
element classes eliminates the tight relationship that both values are
numbers and can complicate using the representation.  Instead, we use
a single element tag and 
disambiguate these literals based on a <code>kind</code> attribute. Thus,
we can still
tell the difference between a floating point literal and an integer
literal, but in the common case we gain the same flexibility of numeric
types that the Java language has.

<p>

Another place where JavaML generalizes language constructs is loops.  
Both <code>for</code> and <code>while</code> loops
can be viewed as general looping constructs with 0 or more initializers,
a guarding test that occurs before each iteration, 0 or more update
operations, and a body of statements that comprise the looped-over
instructions.  Thus, instead of using two classes of elements,
<code>for-loop</code> and <code>while-loop</code>, JavaML uses a single
<code>loop</code> element that has a <code>kind</code> attribute with
value either <code>for</code> or <code>while</code>.  When a
<code>while</code> loop is converted, it will have no initializer and
update children, yet a <code>for</code> loop could potentially contain many
of each.  In contrast <code>do-loop</code> elements are used for
<code>do</code> loops which have their test performed at the end of the
loop, instead of at the start.

  <!--Talk about unparsing loops kind="while" w/ initializer? [as result
  of transformation, say] We definitely can do it, and it's pretty cool
  -->
      
<p>

As yet another example, we represent both instance and class (i.e.,
static) fields as <code>field</code> elements with a <code>static</code>
attribute used to disambiguate.  Although there are more substantial
differences between these two concepts than between <code>while</code>
and <code>for</code> loops, it still seems beneficial to use a single
kind of element for both concepts.

<p>

Local variable declarations provide a syntactic shorthand that raises an
interesting question about their underlying representation.  The code
segment <code>int x, y;</code>
defines two variables both of type <code>int</code>, but with perhaps a
subtle additional intention: that the two variables have the same type.
For contrast, consider <code>int weight, i;</code>.
Here, there probably is <em>not</em> the implicit desire that the two
variables have the same type, but instead the shorthand syntax is being
used simply for brevity.  Because it is hard to automate distinguishing
these cases, JavaML simply preserves this syntactic feature by using a
<code>continued="true"</code> attribute on variable declarations that
exploit this shorthand.

<p>

The careful reader will observe that the JavaML representation is 
about three times longer than the classical source code.  That expansion is a fundamental
tradeoff of moving to a self-describing data format such as XML.
It is important that the terse classical representation can be employed by programmers in
certain tasks including classical development and program editing.
JavaML is complementary to the classical source representation and is especially appropriate
for tools, though still accessible and readable to developers.

<h4><a name="implementation">3.4 - Implementation of converter</a></h4>

To experiment with the design of JavaML and gain experience in using the
representation, it was essential to implement a converter from the Java
classical source representation to JavaML.  Within the IBM Jikes Java
compiler framework <cite>[<a href="#REF-Jikes">Jikes</a>]</cite>, I added an
<code>XMLUnparse</code> method to each of the AST nodes. This change,
along with some small additional code for managing the options to
request the XML output, results in a robust and fast 
JavaML converter.  In total, I added about 1600 non-comment-non-blank
lines of C++ code to the Jikes framework to support the option.  The
source code is available upon request (and will be made publicly
available shortly after final submission of this paper).

<p>

The converter has been tested by converting several sample programs, as
well as the whole of the 4300 line Cassowary Constraint Solving Toolkit
<cite>[<a href="#REF-Cassowary">Cassowary</a>]</cite>.  The processing of all those files takes only
about six seconds on the author's RedHat6-based Pentium III-450 machine.
Each of the files converted was then validated with respect to the
JavaML DTD using James Clark's Jade package's <code>nsgmls</code> tool
<cite>[<a href="#REF-Jade">Jade</a>]</code>.

<p>

Also implemented is a prototype back-converter that outputs the classical
source representation given
the JavaML representation. That application uses the XML and DOM packages
and contains about 360 lines of Perl.
See <a href="#future-work">section 6</a> for
more details about back-converting possibilities.

<p><span class="index"><a href="#top">[top]</a></span>

<h3><a name="leveraging-xml">4 - Leveraging XML</a></h3>

JavaML uses XML as an alternate, structured representation of a Java
source program.  Although the abstraction away from syntactic details of
Java is convenient, the more important benefit is that JavaML enables
the use of the rich infrastructure developed to support SGML and XML.
Instead of building analysis and transformation tools from scratch to
work on a proprietary binary structured format for a program, existing
SGML and XML tools can be used, combined, and extended.  XML tools
encompass a broad range of features that include querying and
transformation, document differencing and merging
<cite>[<a href="#REF-XMLDiffMerge">XMLDiffMerge</a>]</cite>, and simple APIs for working with the
document directly.  In this paper, I will (for space reasons) limit
discussion to uses of only three tool groups:

<ul>
<li> the XML toolbox (ltxml) from Edinburgh University
<cite>[<a href="#REF-ltxml">ltxml</a>]</cite> which contains <code>sgcount</code>,
<code>sgrpg</code>, <code>sggrep</code>, and more;

<li> the perlSGML utilities <cite>[<a href="#REF-perlSGML">perlSGML</a>]</cite>  which
contains <code>dtd2html</code>, <code>dtddiff</code>,
<code>dtdtree</code>, and more; and

<li> the Perl XML::DOM package <cite>[<a href="#REF-perlDOM">perlDOM</a>]</cite> which exposes a
DOM level 1 <cite>[<a href="#REF-DOM">DOM</a>]</cite> interface to an XML tree.
</ul>

These are just a very small subset of the tools that prove useful when
working with JavaML.  In the following examples, we will query the
<code>Set.java.xml</code> document that appears in <a
href="#set.java.xml">Appendix 2b</a>.  Although these examples are small
by real-world standards, XML and SGML tools target documents ranging up
through lengthy books so the implementations are designed to
scale well.

<p>

One common software engineering task (for better or for worse)
is to accumulate metrics about a
source code artifact.  With JavaML, the SGML utility
<code>sgcount</code> does an excellent job of summarizing the constructs
in a Java program:

<pre>
<strong>
% sgcount Set.java.xml
</strong>
<small>
new                    5  
method                 9  
lvalue                 4  
if                     1  
var-set                4  
literal-true           2  
assignment-expr        4  
loop                   1  
formal-argument        7  
package-decl           1  
local-variable         2  
literal-null           2  
target                 18 
cast-expr              1  
constructor            4  
arguments              23 
import                 1  
send                   18 
return                 8  
test                   2  
formal-arguments       13 
class                  1  
java-source-program    1  
true-case              1  
type                   25 
conditional-expr       2  
var-ref                25 
literal-false          2  
statements             25 
literal-string         3  
binary-expr            3  
field                  1  
*Total*                219 
</small>
</pre>

In the above output, each row lists an element class and the number of
times that that element appeared in the document.  Thus, we can easily
see that there are 9 <code>method</code> elements, thus there are 9
method definitions.  Similarly, we can see that there is 1 class
definition, 25 variable references, 18 message sends, and 3 string
literals.  This summary is far more indicative of the content of a
program than a typical lexical measure such as the number of lines of
code.

<p>

Suppose we wish to see all the string literals that a program contains.
We can do this trivially using <code>sggrep</code> on the JavaML
representation of the program:

<pre>
<strong>
% sggrep '.*/literal-string' &lt; Set.java.xml
</strong>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;!DOCTYPE java-source-program SYSTEM "java-ml.dtd" &gt;
&lt;literal-string length='2'&gt;{ &lt;/literal-string&gt;
&lt;literal-string length='2'&gt;, &lt;/literal-string&gt;
&lt;literal-string length='4'&gt; }\n&lt;/literal-string&gt;
</pre>

Notice that the output of <code>sggrep</code> is also a (not necessarily
valid nor even well-formed) XML document.  Thus we can string together
SGML and XML tools in a Unix pipeline to combine tools in novel and
useful ways.  For example, if we want to just see the strings, we can
run <code>stripsgml</code> on the output of the above query:

<pre>
<strong>
% sggrep '.*/literal-string' &lt; Set.java.xml | stripsgml
{ 
, 
 }\n
</strong>
</pre>

<p>

We can also query the JavaML source for elements based on values of
their attributes.  For example, if we wish to find all sends of the
message <code>clone</code> we can do so easily and reliably:

<pre>
<strong>
% sggrep '.*/send[message=clone]' &lt; Set.java.xml 
</strong>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;!DOCTYPE java-source-program SYSTEM "java-ml.dtd" &gt;
&lt;send message='clone'&gt;
&lt;target&gt;
&lt;var-ref name='hash'/&gt;
&lt;/target&gt;
&lt;arguments/&gt;
&lt;/send&gt;
</pre>


Another class of common analyses is the semantic checks done by the
compiler prior to translation.  For example, in Java code, only abstract
classes may have abstract methods.  When compiling, a semantic error
will be flagged if this rule is violated.  We can query a JavaML document
for not-abstract classes that contain a method that is abstract:

<pre>
<strong>
% sggrep -q '.*/class[abstract!=true]/method[abstract=true]' &lt; Set.java.xml
</strong>
</pre>

and the output will be empty because this semantic restriction is not
violated in our target document (i.e., the analyzed program).

<p>

A common error for novice Java programmers is to accidentally use the
assignment operator, <code>=</code>, instead of using the equality test
operator, <code>==</code>.  Although the Java type checker will catch
most of these errors at compile time, it will miss the problem if
the assigned-to variable is a <code>boolean</code>. If we wish to find these
questionable constructs, <code>sggrep</code> makes this analysis
trivial thanks to the JavaML representation:

<pre>
<strong>
% sggrep -q '.*/if/test/assignment-expr' &lt; Set.java.xml
</strong>
</pre>

<p>

The <code>sgrpg</code> (SGML RePort Generator) program permits combining
a top-level query with a restriction on the children and an output
format for the results (a common paradigm for querying tools 
<cite>[<a href="#REF-XMLQL">XMLQL-EnE</a>]</cite>).  For example:

<pre>
<strong>
% sgrpg '.*/method' '.*/send[message=hasMoreElements]' '' '%s %s 
' visibility name &lt; Set.java.xml
</strong>
public toString
</pre>

searches for method definitions that contain message sends of the
message <code>hasMoreElements</code>.  It then outputs the
<code>visibility</code> and <code>name</code> attributes of the
matched elements as shown above.

<p>

A wide variety of analyses are possible just using the querying
capabilities provided by standard XML tools.  Other things we can find
are returns from inside for loops, all definitions of integer variables,
string variables that do not conform to our project's naming convention,
and much more.

<p>

Transformations on source code are also very useful when modifying and
evolving software artifacts.  Obviously, querying tools can only prune
elements from the source document or combine elements from multiple 
documents.  More powerful transformations are
possible using XSLT <cite>[<a href="#REF-XSLT">XSLT</a>]</cite>, DSSSL <cite>[<a href="#REF-DSSSL">DSSSL</a>]</cite>, or
directly manipulating the document using a DOM (Document Object Model)
<cite>[<a href="#REF-DOM">DOM</a>]</cite> interface.  For example, we can rename methods named
<code>isBall</code> to <code>FIsBall</code> using the Perl package 
<code>XML::DOM</code> and the following in the
<code>start_tag</code> subroutine:

<pre>
sub start_tag { 
  my ($this,$tag,$attr_spec) = @_;
  my %attrs = SGMLparse_attr_spec($attr_spec);
  # ...
  if ($tag eq "method") {
    if ($attrs{name} eq "bar") {
      $attrs{name} = "Bar";
    }
  } elsif ($tag eq "send") {
    if ($attrs{message} eq "bar") {
      $attrs{name} = "Bar";
    }
  }
  # ...
}
</pre>

<p>

Other possibilities for transformations include using a style sheet to
convert from JavaML back into the classical source representation or a
PostScript text representation with nice syntax highlighting.  Adding
debug or instrumentation code at entry and exit to and from functions is
also straightforward.

<!--
<p>

GJB:FIXME:: need another transformation example, ideally using XSLT if I
can find a working implementation of that.

* changing sense of a default parameter (via overriding, because no
defaults in Java)

* renaming a method

* search for unused variables

* etags

* add debug/instrumentation code at entry/exit to function/block whatever

* better diff utility; canonical ast differ for cheating check

 -->

<p><span class="index"><a href="#top">[top]</a></span>

<h3><a name="related-work">5 - Related work</a></h3>

A key benefit of JavaML is its ability to leverage the growing
infrastructure of SGML and XML related tools and techniques as described
in <a href="#leveraging-xml">the previous section</a>.  Various researchers
have similarly approached the problem of 
improving software engineering and development
tools with varying degrees of success.

<p>

TAWK <cite>[<a href="#REF-TAWK">TAWK</a>]</cite> extends the AWK <cite>[<a href="#REF-AwkSed">AwkSed</a>]</cite>
paradigm by matching patterns in the AST of a C program.  Numerous XML
querying tools provide this same functionality for JavaML, and the
event-action framework is similar to that used by SAX 
(Simple API for XML) <cite>[<a href="#REF-SAX">SAX</a>]</cite>.

<p>

ASTLog <cite>[<a href="#REF-ASTLog">ASTLog</a>]</cite> extends the Prolog <cite>[<a href="#REF-Prolog">Prolog</a>]</cite>
logic programming language with the ability to reason about an external
database that models the AST.  Unlike Prolog, ASTLog statements are
evaluated with respect to a current object.  The approach that Crew uses
may be interesting to apply to the XML world, but the numerous XML tools
already provide comparable functionality through a more conventional (if
perhaps less convenient) framework. 

<p>

CCEL <cite>[<a href="#REF-CCEL">CCEL</a>]</cite> provides a metalanguage for expressing
non-linguistic intentions (i.e., ones that cannot be expressed in the
language) about software artifacts written in C++.  JavaML can provide a
similar capability by simply writing queries that search for violations
of the intended invariants and reporting them as part of the edit,
build, or regression-test procedure throughout the development cycle.

<!--
<p>

Many structure-based editing systems have been
developed. <cite>[GJB:FIXME::]</cite>.  XML editors are likely to supersede the 
capabilities of prior systems simply because of the commercial
importance of XML technology.
-->
<p>

Microsoft's Intentional Programming group <cite>[<a href="#REF-Simonyi96">Simonyi96</a>]</cite> has
long been working on a more abstract representation of computation that
is syntax-independent.  Their goal appears to be to permit developers to
describe new abstractions along with techniques to reduce those
abstractions down to known primitives.  In essence, they are interested
in permitting the developer to grow a domain-specific language as they
build their software.  JavaML is especially exciting as a representation
for this approach.  We can view new abstractions as incremental
extensions to DTDs.  In order for the new document type, call it Java++ML, to
still be compilable by a stock Java compiler, the developer must simply
write a transformation from Java++ML to JavaML.  Because DTDs are
exceptionally easy to extend, this approach is tenable and likely a
fruitful avenue for future work.  There are several utilities for
documenting and comparing DTDs (e.g., <code>dtd2html</code> and
<code>dtddiff</code>) that would be helpful when applying this
technique.


<p><span class="index"><a href="#top">[top]</a></span>

<h3><a name="future-work">6 - Future work</a></h3>

The one unfortunate shortcoming of the current implementation of the
classical source representation to JavaML converter
is that it loses source-level comments.  Although these
are an essential part of any software artifact, conventional parsing
technology throws the comments away early in the lexical analysis phase.
Because the comments are never a part of the internal representation of
the program inside the Jikes compiler framework, they cannot be unparsed
into JavaML.  Even after modifying the compiler's internal 
representation to support
comments, there will remain the problem of choosing to what element to
attach a given comment.  Although this is a hard problem, the JavaDoc
conventions for documenting source code will simplify properly attaching
a large fraction of the comments.

<p>

Another useful extension to the current transformation system is to do
more cross-linking of elements.  Type elements could reference their
defining classes in other JavaML documents.  Import declarations could
reference the top-level documentation for the imported package.  Many
more possibilities are imaginable.

<p>

JavaML should be refined to guarantee that it is a complete, isomorphic
representation of the constructs present in the latest version of the
Java programming language.  Additionally, it is likely beneficial to
migrate JavaML to use XML Schema <cite>[<a href="#REF-XMLSchema1">XMLSchema1</a>,<a href="#REF-XMLSchema2">XMLSchema2</a>]</cite>
instead of a DTD after the Schema working drafts are finalized.

<p>

Although this paper has presented a markup language for Java,
the same basic approach can be
applied to other programming languages, or even to translate among
languages.  To the extent that the representation abstracts away syntax,
JavaML may also prove useful in permitting the import of visual
representations such as Unified Modeling Language 
diagrams <cite>[<a href="#REF-UMLNutshell">UMLNutshell</a>,<a href="#REF-XMI">XMI</a>]</cite>.  
Certainly generating visual representations of important
properties of software artifacts is on the immediate horizon given the
capabilities of XSL and DSSSL.

<p>

One significant complication in applying this approach to C++, another
popular conventional object-oriented-programming language, is the C
preprocessor.  The C preprocessor provides a first pass of textual
processing to permit abstractions that cannot otherwise be expressed in
the core C++ language.  These abstractions are often very important to
the understandability and maintainability of the code, but do not interact
well with parsing techniques. <cite>[<a href="#REF-EmpAnCpp">EmpAnCpp</a>,<a href="#REF-PCP3">PCP3</a>]</cite>

<p>

The current converter that translates back from JavaML to the classical
source representation needs to be far more robust.  It was written as
only a proof of concept and for the author to gain experience with the
XML DOM.  A better approach is to add a Jikes front-end that uses an XML
parser (e.g., XML4C++ <cite>[<a href="#REF-XML4C++">XML4C++</a>++]</cite>) to construct the XML
DOM from the JavaML source, then simply write a recursive conversion
function to build the Jikes internal AST from using the DOM API.  Then,
using Jikes's pre-existing conventional unparser, the compiler can write
out the classical representation for the source code.  The key benefit of this technique is
that it then permits the compiler to work directly on the JavaML
representation of the source code via the new front-end.

<p>

Using JavaML as the primary source representation has the potential to
simplify the compiler beyond just eliminating its classical front-end. Some
semantic analyses can be removed from the compiler once it knows that
the input is a valid JavaML document.  It will be useful to characterize which
semantic errors are provably impossible to encounter given that
precondition.  Additionally, more semantic analyses can be moved into the
editing environment reasonably painlessly in the form of straightforward
queries (such as some of those described earlier in <a
href="#leveraging-xml">Section 4</a>).

<p>

Because the concise textual representation of source code is nicely suited
to expert programmers, it's unlikely that they will be interested in
discarding their favourite text editor anytime soon.  It will be useful
to investigate better ways to convert interactively and incrementally
from the classical source representation to
JavaML and support useful editing capabilities along the lines of
current text editing systems.  The work on structured text editors is
highly relevant here, but may prove more fruitful given the incredible
resources that can now be thrown at the problem given the growing
commercial importance of XML technology.

<p><span class="index"><a href="#top">[top]</a></span>

<h3><a name="conclusion">7 - Conclusion</a></h3>

JavaML is an alternate representation of Java source programs that is
based on XML.  Unlike the classical textual source representation, the
JavaML representation makes it easy for software tools to reason about
programming-level constructs in a Java program.  This benefit results from the
ability of JavaML to more directly represent the structure of the program.

<p>

Given JavaML, the wealth of pre-existing XML and SGML tools can perform
numerous interesting and useful analyses and transformations of Java
source programs.  XML tools are improving
continually to support the growing infrastructure of XML-based
documents.  Ultimately, JavaML could replace the classical source
representation of Java programs as the storage format for programs,
relegating text-parsing to just one of
many possible ways of interacting directly with the structured
representation of the software artifact throughout the development
process.

<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="acknowledgments">Acknowledgments</a></h3> 

I enthusiastically thank Zack Ives and Stefan Bjarni Sigurdsson for
their comments, discussion, and input on this work.  I thank Corin Anderson
and Alan Borning for much-appreciated comments on a draft of this paper.
I also thank Miguel Figueroa, Craig Kaplan, and Todd Millstein, for their helpful
discussions. Thanks to IBM for constructing the Jikes compiler
framework, and for making it publicly available, and thanks to Mike
Ernst for helpful pointers on using it. This work was supported by the
University of Washington Computer Science and Engineering Wilma Bradley
fellowship and by NSF Grant No. IIS-9975990.

<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="javaml-dtd">Appendix 1 - JavaML DTD</a></h3>
<small>
<pre>
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!ENTITY % visibility-attribute "visibility (public|private|protected)
    #IMPLIED"&gt;
&lt;!ENTITY % kind-attribute "kind (integer|long|real|double) #IMPLIED"&gt;
&lt;!ENTITY % mod-final "final CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-static "static CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-volatile "volatile CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-transient "transient CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-native "native CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-abstract "abstract CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-synchronized "synchronized CDATA #IMPLIED"&gt;
&lt;!ENTITY % expr-elems
    "send|new|new-array|var-ref|field-access|array-ref|paren|assignment-expr|\
conditional-expr|binary-expr|unary-expr|cast-expr|literal-number|literal-string|\
literal-true|literal-false|literal-null|this|super"&gt;
&lt;!ELEMENT java-source-program (package-decl?,import*,(class|interface)+) &gt;
&lt;!ATTLIST java-source-program name CDATA #IMPLIED version CDATA #IMPLIED&gt;
&lt;!ELEMENT import EMPTY&gt;
&lt;!ATTLIST import module CDATA #REQUIRED&gt;
&lt;!ELEMENT class ((implement)*, (constructor|method|field)*) &gt;
&lt;!ATTLIST class name CDATA #REQUIRED %visibility-attribute; %mod-abstract;
    %mod-final; %mod-synchronized; superclass CDATA "Object"&gt;
&lt;!ELEMENT interface ((extend)*, method*) &gt;
&lt;!ATTLIST interface name CDATA #REQUIRED %visibility-attribute;&gt;
&lt;!ELEMENT implement EMPTY&gt;
&lt;!ATTLIST implement class CDATA #REQUIRED&gt;
&lt;!ELEMENT extend EMPTY&gt;
&lt;!ATTLIST extend interface CDATA #REQUIRED&gt;
&lt;!ELEMENT field (type,(%expr-elems;)?)&gt;
&lt;!ATTLIST field name CDATA #REQUIRED %visibility-attribute; %mod-final;
    %mod-static; %mod-volatile; %mod-transient;&gt;
&lt;!ELEMENT constructor
    (formal-arguments,throws*,(super-call|this-call)?,statements)&gt;
&lt;!ATTLIST constructor name CDATA #REQUIRED id ID #REQUIRED
    %visibility-attribute; %mod-final; %mod-static; %mod-synchronized;
    %mod-volatile; %mod-transient; %mod-native;&gt;
&lt;!ELEMENT method (type,formal-arguments,throws*,statements?)&gt;
&lt;!ATTLIST method name CDATA #REQUIRED id ID #REQUIRED
    %visibility-attribute; %mod-abstract; %mod-final; %mod-static;
    %mod-synchronized; %mod-volatile; %mod-transient; %mod-native;&gt;
&lt;!ELEMENT formal-arguments (formal-argument)*&gt;
&lt;!ELEMENT formal-argument (type)&gt;
&lt;!ATTLIST formal-argument name CDATA #REQUIRED id ID #REQUIRED
    %mod-final;&gt;
&lt;!ELEMENT send (target?,arguments)&gt;
&lt;!ATTLIST send message CDATA #REQUIRED&gt;
&lt;!ELEMENT target (%expr-elems;)&gt;
&lt;!ELEMENT return (%expr-elems;)&gt;
&lt;!ELEMENT statements
    (statements|local-variable|try|throw|if|loop|do-loop|return|continue|break|%expr-elems;)*&gt;
&lt;!ELEMENT throw (%expr-elems;)&gt;
&lt;!ELEMENT throws EMPTY&gt;
&lt;!ATTLIST throws exception CDATA #REQUIRED&gt;
&lt;!ELEMENT new (type,arguments)&gt;
&lt;!ELEMENT type EMPTY&gt;
&lt;!ATTLIST type primitive CDATA #IMPLIED name CDATA #REQUIRED dimensions
    CDATA #IMPLIED&gt;
&lt;!ELEMENT new-array (type,dim-expr*,(%expr-elems;)?)&gt;
&lt;!ATTLIST new-array dimensions CDATA #REQUIRED&gt;
&lt;!ELEMENT dim-expr (%expr-elems;)&gt;
&lt;!ELEMENT local-variable (type,(static-initializer|%expr-elems;)?)&gt;
&lt;!ATTLIST local-variable name CDATA #REQUIRED id ID #REQUIRED continued
    CDATA #IMPLIED %mod-final;&gt;
&lt;!ELEMENT arguments (%expr-elems;)*&gt;
&lt;!ELEMENT literal-string (#PCDATA)&gt;
&lt;!ATTLIST literal-string length CDATA #REQUIRED&gt;
&lt;!ELEMENT literal-number EMPTY&gt;
&lt;!ATTLIST literal-number value CDATA #REQUIRED %kind-attribute; base CDATA
    "10"&gt;
&lt;!ELEMENT var-ref EMPTY&gt;
&lt;!ATTLIST var-ref name CDATA #REQUIRED idref IDREF #IMPLIED&gt;
&lt;!ELEMENT field-access (%expr-elems;)&gt;
&lt;!ATTLIST field-access field CDATA #REQUIRED&gt;
&lt;!ELEMENT var-set EMPTY&gt;
&lt;!ATTLIST var-set name CDATA #REQUIRED&gt;
&lt;!ELEMENT field-set (%expr-elems;)&gt;
&lt;!ATTLIST field-set field CDATA #REQUIRED&gt;
&lt;!ELEMENT package-decl EMPTY&gt;
&lt;!ATTLIST package-decl name CDATA #REQUIRED&gt;
&lt;!ELEMENT assignment-expr (lvalue,(%expr-elems;))&gt;
&lt;!ELEMENT lvalue (var-set|field-set|%expr-elems;)&gt;
&lt;!ELEMENT binary-expr ((%expr-elems;),(%expr-elems;))&gt;
&lt;!ATTLIST binary-expr op CDATA #REQUIRED&gt;
&lt;!ELEMENT paren (%expr-elems;)&gt;
&lt;!ELEMENT unary-expr (%expr-elems;)&gt;
&lt;!ATTLIST unary-expr op CDATA #REQUIRED post (true|false) #IMPLIED&gt;
&lt;!ELEMENT cast-expr (type,(%expr-elems;))&gt;
&lt;!ELEMENT literal-false EMPTY&gt;
&lt;!ELEMENT literal-true EMPTY&gt;
&lt;!ELEMENT literal-null EMPTY&gt;
&lt;!ELEMENT if (test,true-case,false-case?)&gt;
&lt;!ELEMENT test (%expr-elems;)&gt;
&lt;!ELEMENT true-case (statements)&gt;
&lt;!ELEMENT false-case (statements)&gt;
&lt;!ELEMENT array-ref (base,offset)&gt;
&lt;!ELEMENT base (%expr-elems;)&gt;
&lt;!ELEMENT offset (%expr-elems;)&gt;
&lt;!ELEMENT static-initializer (statements)&gt;
&lt;!ELEMENT super-call (arguments)&gt;
&lt;!ELEMENT this-call (arguments)&gt;
&lt;!ELEMENT super EMPTY&gt;
&lt;!ELEMENT this EMPTY&gt;
&lt;!ELEMENT loop (init*,test?,update*,statements?)&gt;
&lt;!ATTLIST loop kind (for|while) #IMPLIED&gt;
&lt;!ELEMENT init (local-variable|%expr-elems;)&gt;
&lt;!ELEMENT update (%expr-elems;)&gt;
&lt;!ELEMENT do-loop (statements?,test?)&gt;
&lt;!ELEMENT try (statements,catch*,finally?)&gt;
&lt;!ELEMENT catch (formal-argument,statements?)&gt;
&lt;!ELEMENT finally (statements)&gt;
&lt;!ELEMENT continue EMPTY&gt;
&lt;!ATTLIST continue targetname CDATA #IMPLIED&gt;
&lt;!ELEMENT break EMPTY&gt;
&lt;!ATTLIST break targetname CDATA #IMPLIED&gt;
&lt;!ELEMENT conditional-expr ((%expr-elems;),(%expr-elems;),(%expr-elems;))&gt;
</pre>
</small>

<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="set.java">Appendix 2a - Extended Example, <strong>Set.java</strong></a></h3>
<small>
<pre>
// Cassowary Incremental Constraint Solver
// (C) 1998, 1999 Greg J. Badros and Alan Borning
//
// Set -- Encapsulate a mathematical "Set" ADT using java's
// hash table.  Just a convenience wrapper of the java.util.Hashtable class.

package EDU.Washington.grad.gjb.cassowary;

import java.util.*;

class Set {
  public Set()
    { hash = new Hashtable(); }

  public Set(int i)
    { hash = new Hashtable(i); }

  public Set(int i, float f)
    { hash = new Hashtable(i,f); }

  public Set(Hashtable h) 
    { hash = h; }

  public boolean containsKey(Object o)
    { return hash.containsKey(o); }

  public boolean insert(Object o)
    { return hash.put(o,o) == null? true: false; }

  public boolean remove(Object o)
    { return hash.remove(o) == null? true: false; }

  public void clear()
    { hash.clear(); }

  public int size()
    { return hash.size(); }

  public boolean isEmpty()
    { return hash.isEmpty(); }

  public Object clone()
    { return new Set((Hashtable) hash.clone()); }

  public Enumeration elements()
    { return hash.elements(); }

  public String toString() { 
    StringBuffer bstr = new StringBuffer("{ ");
    Enumeration e = hash.keys();
    if (e.hasMoreElements())
      bstr.append(e.nextElement().toString());
    while ( e.hasMoreElements() ) {
      bstr.append(", " + e.nextElement());
    }
    bstr.append(" }\n");
    return bstr.toString();
  }
  
  private Hashtable hash;
}
</pre>
</small>

<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="set.java.xml">Appendix 2b - Extended Example, <strong>Set.java.xml</strong></a></h3>
<small>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE java-source-program SYSTEM "java-ml.dtd"&gt;

&lt;java-source-program name="Set.java"&gt;
  &lt;package-decl name="EDU.Washington.grad.gjb.cassowary"/&gt;
  &lt;import module="java.util.*"/&gt;
  &lt;class name="Set" superclass="Object"&gt;
    &lt;constructor name="Set" visibility="public" id="ctr-21"&gt;
      &lt;formal-arguments/&gt;
      &lt;statements&gt;
	&lt;assignment-expr&gt;&lt;lvalue&gt;&lt;var-set name="hash"/&gt;&lt;/lvalue&gt;&lt;new&gt;&lt;type name="Hashtable"/&gt;&lt;arguments/&gt;&lt;/new&gt;
	&lt;/assignment-expr&gt;
      &lt;/statements&gt;
    &lt;/constructor&gt;
    &lt;constructor name="Set" visibility="public" id="ctr-30"&gt;
      &lt;formal-arguments&gt;
	&lt;formal-argument name="i" id="frmarg-26"&gt;&lt;type name="int" primitive="true"/&gt;&lt;/formal-argument&gt;
      &lt;/formal-arguments&gt;
      &lt;statements&gt;
	&lt;assignment-expr&gt;&lt;lvalue&gt;&lt;var-set name="hash"/&gt;&lt;/lvalue&gt;&lt;new&gt;&lt;type name="Hashtable"/&gt;&lt;arguments&gt;&lt;var-ref name="i"/&gt;&lt;/arguments&gt;&lt;/new&gt;
	&lt;/assignment-expr&gt;
      &lt;/statements&gt;
    &lt;/constructor&gt;
    &lt;constructor name="Set" visibility="public" id="ctr-43"&gt;
      &lt;formal-arguments&gt;
	&lt;formal-argument name="i" id="frmarg-35"&gt;&lt;type name="int" primitive="true"/&gt;&lt;/formal-argument&gt;
	&lt;formal-argument name="f" id="frmarg-39"&gt;&lt;type name="float" primitive="true"/&gt;&lt;/formal-argument&gt;
      &lt;/formal-arguments&gt;
      &lt;statements&gt;
	&lt;assignment-expr&gt;&lt;lvalue&gt;&lt;var-set name="hash"/&gt;&lt;/lvalue&gt;&lt;new&gt;&lt;type name="Hashtable"/&gt;&lt;arguments&gt;&lt;var-ref name="i"/&gt;&lt;var-ref name="f"/&gt;&lt;/arguments&gt;&lt;/new&gt;
	&lt;/assignment-expr&gt;
      &lt;/statements&gt;
    &lt;/constructor&gt;
    &lt;constructor name="Set" visibility="public" id="ctr-52"&gt;
      &lt;formal-arguments&gt;
	&lt;formal-argument name="h" id="frmarg-48"&gt;&lt;type name="Hashtable"/&gt;&lt;/formal-argument&gt;
      &lt;/formal-arguments&gt;
      &lt;statements&gt;
	&lt;assignment-expr&gt;&lt;lvalue&gt;&lt;var-set name="hash"/&gt;&lt;/lvalue&gt;&lt;var-ref name="h"/&gt;&lt;/assignment-expr&gt;
      &lt;/statements&gt;
    &lt;/constructor&gt;
    &lt;method name="containsKey" visibility="public" id="meth-60"&gt;
      &lt;type name="boolean" primitive="true"/&gt;
      &lt;formal-arguments&gt;
	&lt;formal-argument name="o" id="frmarg-58"&gt;&lt;type name="Object"/&gt;&lt;/formal-argument&gt;
      &lt;/formal-arguments&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;return&gt;&lt;send message="containsKey"&gt;
	      &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
	      &lt;arguments&gt;&lt;var-ref name="o" idref="frmarg-58"/&gt;&lt;/arguments&gt;
	    &lt;/send&gt;
	  &lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="insert" visibility="public" id="meth-69"&gt;
      &lt;type name="boolean" primitive="true"/&gt;
      &lt;formal-arguments&gt;
	&lt;formal-argument name="o" id="frmarg-67"&gt;&lt;type name="Object"/&gt;&lt;/formal-argument&gt;
      &lt;/formal-arguments&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;return&gt;&lt;conditional-expr&gt;&lt;binary-expr op="=="&gt;&lt;send message="put"&gt;
		  &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
		  &lt;arguments&gt;&lt;var-ref name="o" idref="frmarg-67"/&gt;&lt;var-ref name="o" idref="frmarg-67"/&gt;&lt;/arguments&gt;
		&lt;/send&gt;
		&lt;literal-null/&gt;&lt;/binary-expr&gt;&lt;literal-true/&gt;&lt;literal-false/&gt;&lt;/conditional-expr&gt;&lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="remove" visibility="public" id="meth-78"&gt;
      &lt;type name="boolean" primitive="true"/&gt;
      &lt;formal-arguments&gt;
	&lt;formal-argument name="o" id="frmarg-76"&gt;&lt;type name="Object"/&gt;&lt;/formal-argument&gt;
      &lt;/formal-arguments&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;return&gt;&lt;conditional-expr&gt;&lt;binary-expr op="=="&gt;&lt;send message="remove"&gt;
		  &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
		  &lt;arguments&gt;&lt;var-ref name="o" idref="frmarg-76"/&gt;&lt;/arguments&gt;
		&lt;/send&gt;
		&lt;literal-null/&gt;&lt;/binary-expr&gt;&lt;literal-true/&gt;&lt;literal-false/&gt;&lt;/conditional-expr&gt;&lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="clear" visibility="public" id="meth-82"&gt;
      &lt;type name="void" primitive="true"/&gt;
      &lt;formal-arguments/&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;send message="clear"&gt;
	    &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
	    &lt;arguments/&gt;
	  &lt;/send&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="size" visibility="public" id="meth-88"&gt;
      &lt;type name="int" primitive="true"/&gt;
      &lt;formal-arguments/&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;return&gt;&lt;send message="size"&gt;
	      &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
	      &lt;arguments/&gt;
	    &lt;/send&gt;
	  &lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="isEmpty" visibility="public" id="meth-93"&gt;
      &lt;type name="boolean" primitive="true"/&gt;
      &lt;formal-arguments/&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;return&gt;&lt;send message="isEmpty"&gt;
	      &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
	      &lt;arguments/&gt;
	    &lt;/send&gt;
	  &lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="clone" visibility="public" id="meth-98"&gt;
      &lt;type name="Object"/&gt;
      &lt;formal-arguments/&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;return&gt;&lt;new&gt;&lt;type name="Set"/&gt;&lt;arguments&gt;&lt;cast-expr&gt;&lt;type name="Hashtable"/&gt;&lt;send message="clone"&gt;
		    &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
		    &lt;arguments/&gt;
		  &lt;/send&gt;
		&lt;/cast-expr&gt;&lt;/arguments&gt;&lt;/new&gt;
	  &lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="elements" visibility="public" id="meth-103"&gt;
      &lt;type name="Enumeration"/&gt;
      &lt;formal-arguments/&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;return&gt;&lt;send message="elements"&gt;
	      &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
	      &lt;arguments/&gt;
	    &lt;/send&gt;
	  &lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;method name="toString" visibility="public" id="meth-108"&gt;
      &lt;type name="String"/&gt;
      &lt;formal-arguments/&gt;
      &lt;statements&gt;
	&lt;statements&gt;
	  &lt;local-variable name="bstr" id="locvar-216"&gt;
               &lt;type name="StringBuffer"/&gt;
               &lt;new&gt;&lt;type name="StringBuffer"/&gt;
                 &lt;arguments&gt;&lt;literal-string length="2"&gt;{ &lt;/literal-string&gt;&lt;/arguments&gt;&lt;/new&gt;
	  &lt;/local-variable&gt;
	  &lt;local-variable name="e" id="locvar-223"&gt;&lt;type name="Enumeration"/&gt;&lt;send message="keys"&gt;
	      &lt;target&gt;&lt;var-ref name="hash"/&gt;&lt;/target&gt;
	      &lt;arguments/&gt;
	    &lt;/send&gt;
	  &lt;/local-variable&gt;
	  &lt;if&gt;&lt;test&gt;&lt;send message="hasMoreElements"&gt;
		&lt;target&gt;&lt;var-ref name="e" idref="locvar-223"/&gt;&lt;/target&gt;
		&lt;arguments/&gt;
	      &lt;/send&gt;
	    &lt;/test&gt;
	    &lt;true-case&gt;&lt;statements&gt;
		&lt;send message="append"&gt;
		  &lt;target&gt;&lt;var-ref name="bstr"/&gt;&lt;/target&gt;
		  &lt;arguments&gt;&lt;send message="toString"&gt;
		      &lt;target&gt;&lt;send message="nextElement"&gt;
			  &lt;target&gt;&lt;var-ref name="e"/&gt;&lt;/target&gt;
			  &lt;arguments/&gt;
			&lt;/send&gt;
		      &lt;/target&gt;
		      &lt;arguments/&gt;
		    &lt;/send&gt;
		  &lt;/arguments&gt;
		&lt;/send&gt;
	      &lt;/statements&gt;
	    &lt;/true-case&gt;
	  &lt;/if&gt;
	  &lt;statements&gt;
	    &lt;loop kind="while"&gt;&lt;test&gt;&lt;send message="hasMoreElements"&gt;
		  &lt;target&gt;&lt;var-ref name="e"/&gt;&lt;/target&gt;
		  &lt;arguments/&gt;
		&lt;/send&gt;
	      &lt;/test&gt;&lt;statements&gt;
		&lt;send message="append"&gt;
		  &lt;target&gt;&lt;var-ref name="bstr"/&gt;&lt;/target&gt;
		  &lt;arguments&gt;&lt;binary-expr op="+"&gt;&lt;literal-string length="2"&gt;, &lt;/literal-string&gt;&lt;send message="nextElement"&gt;
			&lt;target&gt;&lt;var-ref name="e"/&gt;&lt;/target&gt;
			&lt;arguments/&gt;
		      &lt;/send&gt;
		    &lt;/binary-expr&gt;&lt;/arguments&gt;
		&lt;/send&gt;
	      &lt;/statements&gt;
	    &lt;/loop&gt;
	  &lt;/statements&gt;
	  &lt;send message="append"&gt;
	    &lt;target&gt;&lt;var-ref name="bstr" idref="locvar-216"/&gt;&lt;/target&gt;
	    &lt;arguments&gt;&lt;literal-string length="4"&gt; }\n&lt;/literal-string&gt;&lt;/arguments&gt;
	  &lt;/send&gt;
	  &lt;return&gt;&lt;send message="toString"&gt;
	      &lt;target&gt;&lt;var-ref name="bstr" idref="locvar-216"/&gt;&lt;/target&gt;
	      &lt;arguments/&gt;
	    &lt;/send&gt;
	  &lt;/return&gt;
	&lt;/statements&gt;
      &lt;/statements&gt;
    &lt;/method&gt;
    &lt;field name="hash" visibility="private"&gt;&lt;type name="Hashtable"/&gt;&lt;/field&gt;
  &lt;/class&gt;
&lt;/java-source-program&gt;
</pre>
</small>


<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="references">References</a></h3>

<small>

<p>
<a name="REF-ASTLog"><strong>[ASTLog]</strong></a> &nbsp;
Roger Crew.
"ASTLOG: A Language for Examining Abstract Syntax Trees".
<em>Proceedings of the USENIX Conference on Domain-Specific Languages</em>
October 1997. Santa Barbara, California.

<p>
<a name="REF-AwkSed"><strong>[AwkSed]</strong></a> &nbsp;
Dale Dougherty.
<em>Sed and Awk</em>
O'Reilly and Associates, 1990.


<p>
<a name="REF-C++"><strong>[C++]</strong></a> &nbsp;
Bjarne Stoustrup.
<em>The C++ Programming Language</em>, 3rd ed.
Addison-Wesley, 1997.

<p>
<a name="REF-Cassowary"><strong>[Cassowary]</strong></a> &nbsp;
Greg Badros and Alan Borning.
"The Cassowary Linear Arithmetic Constraint Solving Algorithm: Interface and Implementation".
University of Washington TR UW-CSE-98-06-04.

<p>
<a name="REF-CCEL"><strong>[CCEL]</strong></a> &nbsp;
Carolyn K. Duby, Scott Meyers, Steven P. Reiss.
"CCEL: A Metalanguage for C++".
<em>Proceedings of the USENIX 1992 C++ Conference</em>.
August 1992. Portland, Oregon.

<p>
<a name="REF-CSS2"><strong>[CSS2]</strong></a> &nbsp;
Bert Bos, H&aring;kon Wium Lie, Chris Lilley, and Ian Jacobs, eds.
<em>Cascading Style Sheets, level 2</em>.  W3C Recommendation.
<code><a href="http://www.w3.org/TR/REC-CSS2">http://www.w3.org/TR/REC-CSS2</a></code>

<p>
<a name="REF-DOM"><strong>[DOM]</strong></a> &nbsp;
V. Apparao, S. Byrne, M. Champion, S. Isaacs, I. Jacobs,
A. Le Hors, G. Nicol, J. Robie, R. Sutor, C. Wilson,
and L. Wood, eds.
<em>Document Object Model (DOM) Level 1</em>.  W3C Recommendation.
<code><a href="http://www.w3.org/TR/REC-DOM-Level-1">http://www.w3.org/TR/REC-DOM-Level-1</a></code>

<p>
<a name="REF-DSSSL"><strong>[DSSSL]</strong></a> &nbsp;
<em>Document Style Semantics and Specification Language (DSSSL)</em>.
ISO/IEC 10179:1996.
<code><a href="http://www.jclark.com/dsssl">http://www.jclark.com/dsssl</a></code>

<p>
<a name="REF-EmpAnCpp"><strong>[EmpAnCpp]</strong></a> &nbsp;
Michael Ernst, Greg Badros, and David Notkin.
"An Empirical Study of C Preprocessor Use".
University of Washington TR UW-CSE-97-04-06.
<code><a href="http://www.cs.washington.edu/homes/mernst/pubs/empirical-tr970406-abstract.html">http://www.cs.washington.edu/homes/mernst/pubs/empirical-tr970406-abstract.html</a></code>

<p>
<a name="REF-Jade"><strong>[Jade]</strong></a> &nbsp;
James Clark.
James' DSSSL Engine.
<code>http://www.jclark.com/jade</code>

<p>
<a name="REF-Java"><strong>[Java]</strong></a> &nbsp; 
Ken Arnold and James Gosling.
<em>The Java Programming Language</em>, 2nd ed.
Addison Wesley Longman, 1997.

<p>
<a name="REF-JavaNutshell"><strong>[JavaNutshell]</strong></a> &nbsp;
David Flanagan.
<em>Java in a Nutshell</em>, 2nd ed.
O'Reilly and Associates, 1996.

<p>
<a name="REF-JavaSpec"><strong>[JavaSpec]</strong></a> &nbsp; 
James Gosling, Bill Joy, and Guy Steele. 
<em>The Java Language Specification</em>.
Addison-Wesley, 1996.

<p>
<a name="REF-Jikes"><strong>[Jikes]</strong></a> &nbsp;
IBM Jikes Java Compiler.
<code><a href="http://www.alphaworks.ibm.com/tech/Jikes">http://www.alphaworks.ibm.com/tech/Jikes</a></code>

<p>
<a name="REF-LaTeXWeb"><strong>[LaTeXWeb]</strong></a> &nbsp;
Michael Goosens and Sebastian Rahtz.
<em>The LaTeX Web Companion</em>.
Addison Wesley Longman, 1999.

<p>
<a name="REF-LexYacc"><strong>[LexYacc]</strong></a> &nbsp;
Levine, John R.
<em>Lex & Yacc</em>, 2nd ed.
O'Reilly and Associates, 1992.

<p>
<a name="REF-ltxml"><strong>[ltxml]</strong></a> &nbsp;
Language Technology Group, University of Edinburgh.
LT XML version 1.1.
<code><a href="http://www.ltg.ed.ac.uk/software/xml">http://www.ltg.ed.ac.uk/software/xml</a></code>

<p>
<a name="REF-Modula-2"><strong>[Modula-2]</strong></a> &nbsp;
British Standards Institution.
<em>Modula-2 Draft International Standard</em>, ISO-94.
June 1994.

<p>
<a name="REF-Montana"><strong>[Montana]</strong></a> &nbsp;
Danny Soroker, Michael Karasick, John Barton, and David Streeter.
"Extension Mechanisms in Montana".
<em>Proceedings of 8th Israeli Conference on Computer-Based Systems and Software Engineering</em>.
June 1997.

<p>
<a name="REF-PCP3"><strong>[PCP3]</strong></a> &nbsp;
Greg Badros and David Notkin.
"A Framework for Preprocessor-aware C Source Code Analyses".
To appear: Software &#151; Practice and Experience.
<code><a href="http://www.cs.washington.edu/homes/gjb/papers/cpp-aware-c-analyses.pdf">http://www.cs.washington.edu/homes/gjb/papers/cpp-aware-c-analyses.pdf</a></code>

<p>
<a name="REF-perlSGML"><strong>[perlSGML]</strong></a> &nbsp;
Earl Hood.
perlSGML library.
<code><a href="http://www.oac.uci.edu/indiv/ehood/perlSGML.html">http://www.oac.uci.edu/indiv/ehood/perlSGML.html</a></code> 

<p>
<a name="REF-perlDOM"><strong>[perlDOM]</strong></a> &nbsp;
Enno Derksen and Clark Cooper.
Perl <code>XML::DOM</code> module.
<code><a href="http://users.erols.com/enno/dom/">http://users.erols.com/enno/dom/</a></code>

<p>
<a name="REF-perlXMLParser"><strong>[perlXMLParser]</strong></a> &nbsp;
Larry Wall and Clark Cooper.
Perl <code>XML::Parser</code> module.
<code><a href="http://wwwx.netheaven.com/~coopercc/xmlparser/intro.html">http://wwwx.netheaven.com/~coopercc/xmlparser/intro.html</a></code>

<p>
<a name="REF-Prolog"><strong>[Prolog]</strong></a> &nbsp;
W. F. Clocksin and C. S. Mellish.
<em>Programming in Prolog</em>.
Springer-Verlang, 1994.


<p>
<a name="REF-SAX"><strong>[SAX]</strong></a> &nbsp;
Megginson Technologies.
"SAX 1.0: The Simple API for XML". Web page.
<code><a href="http://www.megginson.com/SAX">http://www.megginson.com/SAX</a></code>

<p>
<a name="REF-SGML"><strong>[SGML]</strong></a> &nbsp;
<em>Standard Generalized Markup Language (SGML)</em>.
ISO 8879:1986.
<code><a href="http://www.iso.ch/cate/d16387.html">http://www.iso.ch/cate/d16387.html</a></code>

<p>
<a name="REF-Simonyi96"><strong>[Simonyi96]</strong></a> &nbsp;
Charles Simonyi.
"Intentional Programming - Innovation in the Legacy Age".
<emph>International Federation for Information Processing WG 2.1 meeting</emph>.
June 1996.

<p>
<a name="REF-Smalltalk"><strong>[Smalltalk]</strong></a> &nbsp;
Adele Goldberg and David Robson.
<em>Smalltalk-80: The Language</em>.
Addison-Wesley, 1989.


<p>
<a name="REF-TAWK"><strong>[TAWK]</strong></a> &nbsp;
William G. Griswold and Darren C. Atkinson.
"Fast, Flexible Syntactic Pattern Matching and Processing".
<em>Proceedings of the IEEE 1996 Workshop on Program Comprehension</em>.
March 1996.


<p>
<a name="REF-UMLNutshell"><strong>[UMLNutshell]</strong></a> &nbsp;
Sinan Si Alhir.
<em>UML in a Nutshell</em>.
O'Reilly and Associates, 1998.

<p>
<a name="REF-XMI"><strong>[XMI]</strong></a> &nbsp;
IBM AlphaWorks.
XML Metadata Interchange (XMI) Toolkit.
<code><a href="http://www.alphaworks.ibm.com/tech/xmitoolkit">http://www.alphaworks.ibm.com/tech/xmitoolkit</a></code>

<p>
<a name="REF-XML"><strong>[XML]</strong></a> &nbsp;
Tim Bray, Jean Paoli, and C. M. Sperberg-McQueen, eds.
<em>Extensible Markup Language (XML) 1.0</em>
<code><a href="http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</a></code>

<p>
<a name="REF-XML4C++"><strong>[XML4C++]</strong></a> &nbsp;
IBM AlphaWorks.
XML for C++.
<code><a href="http://www.alphaworks.ibm.com/tech/xml4c">http://www.alphaworks.ibm.com/tech/xml4c</a></code>

<p>
<a name="REF-XMLDiffMerge"><strong>[XMLDiffMerge]</strong></a> &nbsp;
IBM AlphaWorks.
XML Diff and Merge Tool.
<code><a href="http://www.alphaworks.ibm.com/tech/xmldiffmerge">http://www.alphaworks.ibm.com/tech/xmldiffmerge</a></code>

<p>
<a name="REF-XML-Handbook"><strong>[XML-Handbook]</strong></a> &nbsp;
Charles F. Goldfarb and Paul Prescod.
<em>The XML Handbook</em>
Prentice Hall PTR, 1998.

<p>
<a name="REF-XMLQL"><strong>[XMLQL-EnE]</strong></a> &nbsp;
Mary Fernandez, J&eacute;r&ocirc;me Sim&eacute;on, and Philip Wadler.
"XML Query Language: Experiences and Exemplars"
<code><a href="http://www-db.research.bell-labs.com/usr/simeon/xquery.html">http://www-db.research.bell-labs.com/usr/simeon/xquery.html</a></code>

<p>
<a name="REF-XMLSchema1"><strong>[XMLSchema1]</strong></a> &nbsp;
Henry S. Thompson, David Beech, Murray Maloney, Noah Mendelsohn, eds.
<em>XML Scheme Part 1: Structures</em>. W3c Working Draft 5 Nov 1999.
<code><a href="http://www.w3.org/TR/xmlschema-1">http://www.w3.org/TR/xmlschema-1</a></code>

<p>
<a name="REF-XMLSchema2"><strong>[XMLSchema2]</strong></a> &nbsp;
Paul V. Biron, Ashok Malhotra, eds.
<em>XML Scheme Part 2: Datatypes</em>. W3c Working Draft 5 Nov 1999.
<code><a href="http://www.w3.org/TR/xmlschema-2">http://www.w3.org/TR/xmlschema-2</a></code>

<p>
<a name="REF-XPath"><strong>[XPath]</strong></a> &nbsp;
James Clark and Steve DeRose, eds.
<em>XML Path Langauge (XPath) Version 1.0</em>. W3C Recommendation.
<code><a href="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</a></code>

<p>
<a name="REF-XSL"><strong>[XSL]</strong></a> &nbsp;
Stephen Deach, ed.
<em>Extensible Stylesheet Language (XSL) Specification</em>. W3C Working Draft 21 Apr 1999.
<code><a href="http://www.w3.org/TR/WD-xsl">http://www.w3.org/TR/WD-xsl</a></code>

<p>
<a name="REF-XSLT"><strong>[XSLT]</strong></a> &nbsp;
James Clark, ed.
<em>XSL Transformations</em>.  W3C Recommendation.
<code><a href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a></code>

<!--
<p>
<strong>[XML10Points]</strong> &nbsp;
http://www.w3.org/XML/1999/XML-in-10-points
-->

</small>
<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="vitae">Vitae</a></h3>

<IMG ALT="Greg J. Badros" SRC="./gjb-face-transp.gif" width=75><br>

<strong><a href="http://www.cs.washington.edu/homes/gjb">Greg J. 
Badros</a></strong> is a final-year Ph.D. candidate at the
<a href="http://www.cs.washington.edu">University of Washington</a>
in Seattle, Washington where he earned his
M.Sc. degree in 1998.  He graduated <i>magna cum laude</i> with a
B.S. degree in <a href="http://www.math.duke.edu">Mathematics</a> and 
<a href="http://www.cs.duke.edu">Computer Science</a> from
<a href="http://www.duke.edu">Duke University</a> in
1995.  He is the primary author of the <a
href="http://scwm.mit.edu">Scheme Constraints Window Manager</a> and the
<a href="http://www.cs.washington.edu/research/constraints/cassowary/">Cassowary
Constraint Solving Toolkit</a>.  His research interests include
constraint technology, software engineering, languages, and the
internet.

<hr>
<a href="#introduction">Introduction</a> &nbsp;
<a href="#background">Background</a> &nbsp;
<a href="#javaml">JavaML</a>  &nbsp;
<a href="#leveraging-xml">Leveraging XML</a> <br>
<a href="#related-work">Related work</a>  &nbsp;
<a href="#future-work">Future work</a>  &nbsp;
<a href="#conclusion">Conclusion</a>  &nbsp; 
<a href="#acknowledgments">Acknowledgments</a>  <br>
<a href="#javaml-dtd">Appendix 1 - JavaML DTD</a> &nbsp;
<a href="#set.java">Appendix 2a</a>, <a href="#set.java.xml">2b</a> <a href="#set.java">Extended Example </a>  &nbsp;
<a href="#references">References</a>  &nbsp;
<a href="#vitae">Vitae</a> 

<p><span class="index"><a href="#top">[top]</a></span>

<hr>
<address>
      <a href="http://www.cs.washington.edu/homes/gjb">Greg J. Badros</a> / 
      <a href="http://www.cs.washington.edu">U Washington Computer Science and Engineering</a> /
      <a href="mailto:gjb@cs.washington.edu">gjb@cs.washington.edu</a></address>
</body>
</html>
