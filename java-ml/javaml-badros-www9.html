<!--$Id$-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>
JavaML: A Markup Language for Java Source, by Greg J. Badros
</title>
<!--
  Title 
  Authors 
  Affiliations 
  Abstract 
  Keywords 
  Main body of text 
  Acknowledgements 
  Appendix 
  References 
  Vitae 
-->
<STYLE TYPE="text/css">
<!--
BODY { BACKGROUND-COLOR: #ffffff; FONT-FAMILY: arial, times new roman, sans-serif; }
A:link, A:visited, A:active { TEXT-DECORATION: none; FONT-WEIGHT: bold; COLOR: #0000FF}

H1, H2 { TEXT-ALIGN: center; FONT-WEIGHT: bold; }
H3, H4, H5 { TEXT-ALIGN: left; FONT-WEIGHT: bold; }
H6 { TEXT-ALIGN: center; FONT-WEIGHT: bold; FONT-SIZE: small; }
H6.CAPTION { TEXT-ALIGN: center; FONT-WEIGHT: bold; FONT-SIZE: small; FONT-STYLE: italic; }

P { TEXT-INDENT: 1em; }
P.CODE { TEXT-INDENT: 0; COLOR: #FF0000; }

UL, OL, DL { FONT-SIZE: small; }
UL { list-style: square; }
LI { FONT-SIZE: small; FONT-WEIGHT: bold; }
UL EM, OL EM { FONT-WEIGHT: bold; }
CODE, CITE { FONT-WEIGHT: bold; }
DD { MARGIN-TOP: 5em; margin-left: 5em }

BLOCKQUOTE { MARGIN-LEFT: 1em; MARGIN-RIGHT: 1em }
IMG { VERTICAL-ALIGN: top; ALIGN: center; }
SUP { COLOR: #0000FF; FONT-SIZE: small; }
-->
</STYLE>
</head>
<body>
<h2>
<a name="top">JavaML: A Markup Language for Java Source Code</a>
</h2>
<h6><a href="http://www.cs.washington.edu/homes/gjb">Greg J. Badros</a><br>
<a href="http://www.cs.washington.edu">Department of Computer Science and Engineering</a><br>
<a href="http://www.washington.edu">University of Washington</a><br>
<a href="http://www.cs.washington.edu/homes/gjb/JavaML/">JavaML Home Page</a></h6>

<hr>
<a href="#introduction">Introduction</a> &nbsp;
<a href="#background">Background</a> &nbsp;
<a href="#javaml">Java Markup Language (JavaML)</a> &nbsp; <br>
<a href="#leveraging-xml">Leveraging XML</a> &nbsp;
<a href="#related-work">Related work</a>  &nbsp;
<a href="#future-work">Future work</a>  &nbsp;
<a href="#conclusion">Conclusion</a>  &nbsp;  <br>
<a href="#acknowledgments">Acknowledgments</a> &nbsp;
<a href="#javaml-dtd">Appendix A - JavaML DTD</a> &nbsp;
<a href="#references">References</a>  &nbsp;
<a href="#vitae">Vitae</a> 

<hr>

<h3><a name="abstract">Abstract</a></h3>

The classical plain-text representation of source code is convenient for
programmers but requires parsing to uncover the deep structure of the
program.  While sophisticated software tools parse source code to gain
access to the program's structure, many lightweight programming aids
such as <code>grep</code> rely instead on only the lexical structure of
source code.  I describe a new XML application that provides an
alternative representation of Java source code. This XML-based
representation, called JavaML, is more natural for tools and permits
easy specification of numerous software-engineering analyses by
leveraging the abundance of XML tools and techniques.  A robust
converter built with the Jikes Java compiler framework translates
from the classical Java source code representation to JavaML, and an
XSLT stylesheet converts from JavaML back into the classical textual
form.

<h3><a name="keywords">Keywords</a></h3>

Java, XML, abstract syntax tree representation, software-engineering
analysis, Jikes compiler.

<h3><a name="introduction">1 - Introduction</a></h3>

<p>
Since the first computer programming languages, programmers have used a
text representation as the medium for encoding software structure and
computation.  Over the years, techniques have been developed that
largely mechanize the front-end of compilers &#151; the part that performs the lexical
analysis and parsing necessary to uncover the structure of programming
language constructs represented as plain text.  Tools such as Lex/Flex
and Yacc/Bison <tt><a href="#ref-42">[42]</a></tt> automate these tedious tasks by using
well-founded concepts of regular expressions and grammars. Regular
expressions describe how individual characters combine to form tokens,
and the grammar enumerates how higher-level constructs are composed
recursively of other constructs and primitive tokens.  Together, these
procedures convert a sequence of characters into a data structure
called an <em>abstract syntax tree</em> (AST) which more directly reflects
the structure of the program.
</p><p>
The textual representation of source code has several nice properties.
It is fairly concise and is similar to natural languages, often making it
easy to read.  Text is a universal data format thus making source code
easy to exchange and manipulate using a wide variety of tools including
text editors, version control systems, and command pipeline utilities
such as <code>grep</code>, <code>awk</code>, and <code>wc</code>.
</p><p>
Nevertheless, the classical source representation has numerous problems.
The syntax of popular contemporary languages such as C++ and Perl push
the limits of parsing capabilities.  Constructing a front-end for such
languages is difficult despite the support from tools.  Perhaps more
disconcerting is that evolving the syntax of the language often requires
manipulating a fragile grammar.  This limitation complicates handling an
evolving language.

<p><span class="index"><a href="#top">[top]</a></span>

 <h4><a name="tools">1.1 - Text representation and software tools</a></h4>

<p>
The most significant limitation of the classical source
representation is that the structure of the program is made manifest
only after parsing.  This shortcoming forces language-specific parsing
functionality to be duplicated in every tool that needs to reason about
the program beyond its lexical nature.  Compilers, by necessity, must
work with the AST, and numerous other software-engineering tools would
benefit from access to a structured representation of the
source code.  Unfortunately, many software-engineering tools do not
embed a parser and thus are limited to lexical tasks.
</p><p>
There are several reasons why tool developers often avoid embedding a
parser in tools.  As mentioned previously, building a complete front-end
is challenging for syntactically-complex languages.  Although re-use
(e.g., of the grammar definition) simplifies the
implementation, the resulting AST is not always intuitive.
An AST typically reflects quirky artifacts of the grammar rather than
representing the programming-level constructs directly.  Additionally,
embedding the front-end of a compiler may be deemed overkill when
targeting a simple analysis that can do "well enough" with lexical
information.
</p><p>
Other complications arise if a transformation of the source code is
desired: a change in the AST must ultimately be reflected in the
classical source representation because that is the primary long-term
storage format.  Recreating a text representation from an AST is most
straightforwardly done using an unparsing approach that can create
undesired lexical side effects (e.g., changes in indentation or
whitespace).  Such changes can confuse the other lexical tools that a developer relies
upon.  For example, a version control system is unable to disambiguate
between a meaningful change and a gratuitous one effected
unintentionally.  
</p><p>
Finally, using a parser in a tool necessarily targets
that tool to a specific language, thus reducing its applicability and
generality.  Worse, because there is no standard structured external
representation of a source program, supporting inter-operability of
independent tools even targeting the same programming language is very
difficult.
</p><p>
The end result of these complications is that developers often use
simple, lexically-oriented tools such as <code>grep</code> or
search-and-replace within an editor.  This approach sacrifices accuracy:
imagine wanting to rename a local variable from <code>result</code> to
<code>answer</code>.  With simple search-and-replace, all occurrences of
the word will be changed, even if they refer to characters inside
comments, literal strings, or an unrelated instance field.
</p><p>
An alternate route taken by some developers is to rely instead on
a fixed set of tools provided within an integrated development
environment (IDE) that has access to the structure of their source
program via an integrated language-specific parser.  This approach
sacrifices flexibility.  IDEs generally provide only a limited set of
capabilities and extending those is hard.  Additionally, analyses and
transformation on source code are often hard to automate or perform in
batch using existing interactive environments.  Some more advanced IDEs,
such as IBM VisualAge for C++ <tt><a href="#ref-48">[48]</a></tt>, expose an application
programming interface to the representation of the program.  Although an
improvement, this technique still suffers from an inability to separate
simple tools from a complex environment and additionally creates a
dependency on proprietary technology that may be undesirable.
</p>

<p><span class="index"><a href="#top">[top]</a></span>

 <h4><a name="solution">1.2 - A solution</a></h4>
<p>
One of the fundamental issues underlying the above problems is the
lack of a canonical structured representation of the source code.  We
need a universal format for directly representing program structure that
software tools can easily analyze and manipulate.  The key observation
is that XML, the eXtensible Markup Language <tt><a href="#ref-9">[9]</a></tt>, provides exactly
this capability and is an incredibly empowering complementary
representation for source code.
</p><p>
In this paper, I introduce the Java Markup Language, JavaML &#151; an XML
application for describing Java source programs.  The JavaML document
type definition (DTD) specifies the various elements of a valid JavaML
document and how they may be combined.  There is a natural
correspondence between the elements and their attributes and the
programming language constructs they model.  The structure of the source
program is reflected in the nesting of elements in the JavaML document.
With this representation, we can then leverage the wealth of tools for
manipulating and querying XML and SGML documents to provide a rich, open
infrastructure for software engineering transformations and analyses on
Java source code.
</p><p>
JavaML is well-suited to be used as a canonical representation of Java
source code for tools.  It shares most of the strengths of the classical
representation and overcomes many weaknesses.  The next section
describes relevant features of Java and XML and
<a href="#javaml">section 3</a>
details the markup language and the implementations of converters between
the classical representation and JavaML.  
<a href="#leveraging-xml">Section 4</a>
gives numerous examples of how existing XML and SGML tools can be
exploited to perform source code analyses and transformations on the
richer representation provided by JavaML.  Sections 
<a href="#related-work">5</a>
and 
<a href="#future-work">6</a> describe related work and suggest avenues for
exciting future work, and <a href="#conclusion">section 7</a> concludes.  The
full document type definition (DTD) for JavaML appears in
<a href="#javaml-dtd">appendix A</a> and further examples of converted source
code are available from the author's <a href="http://www.cs.washington.edu/homes/gjb/JavaML/">JavaML web page</a> <tt><a href="#ref-4">[4]</a></tt>.

<p><span class="index"><a href="#top">[top]</a></span>

<h3><a name="background">2 - Background</a></h3>
<p>
The Java Markup Language is influenced by and benefits from numerous
features of the two technologies it builds a bridge between: Java and
XML.
</p>
 <h4><a name="java">2.1 - Java</a></h4>
<p>
Although the XML-based representation of programming language constructs
is language independent, Java is an excellent candidate for experimenting with these
ideas and techniques.
</p><p>
Java is a popular object-oriented programming language developed by Sun
Microsystems in the mid-1990s <tt><a href="#ref-3">[3]</a><a href="#ref-25">[25]</a></tt>.  It features a
platform-independent execution model based on the Java Virtual Machine
(JVM) and owes its quick acceptance to its use as a programming language
for World Wide Web applications.  Java combines a simple object model
reminiscent of Smalltalk <tt><a href="#ref-26">[26]</a></tt> with Algol block structure, a
C++-like <tt><a href="#ref-49">[49]</a></tt> syntax, a static type system, and a package system
inspired by Modula-2 <tt><a href="#ref-10">[10]</a></tt>.
</p><p>
As in most other object-oriented (OO) languages, the primary unit of
decomposition in Java is a <em>class</em> which specifies the behaviour of
a set of objects.  Each class can define several <em>methods</em>, or
behaviours, similar to functions or procedures. A class can also define
<em>fields</em>, or state variables, that are associated with <em>instances</em>
of the class called <em>objects</em>. Classes can inherit behaviour and
state from <em>superclasses</em>, thus forming a hierarchy of
inter-related classes that permits factoring related code into classes
at the top of the hierarchy, and encourages re-use.  Behaviours are
invoked by sending a <em>message</em> to a target receiver object that is
a request to execute a method defined for that class.  Choosing what
method to execute in response to a message is called <em>dynamic
  dispatch</em> and is based on the run-time class of the object receiving
the message.  For example, an instance of the <code>ColoredBall</code>
class may respond to the <code>draw</code> message differently than an
instance of a <code>Ball</code> class.  This ability to behave differently
upon receipt of the same message is largely responsible for the
extensibility benefits touted by the OO community.
</p><p>
Java is being widely used both in industry and in education, and it
remains popular as a programming language on the web.  Unlike C++, a
Java class definition exists in a single, self-contained file.  There
are no separate header files and implementation files, and Java is
largely free from order-dependencies of definitions.  A method body
(when present) is always defined immediately following the declaration
of the method signature.  Additionally, Java lacks an integrated
preprocessor.  These features combine to make Java source programs
syntactically very clean and make Java an ideal language for
representing using XML. (The applicability of this approach to
other languages is discussed further in <a href="#future-work">section 6</a>.)
</p>

  <h4><a name="xml">2.2 - XML: Extensible Markup Language</a></h4>
<p>
XML is a standardized eXtensible Markup Language <tt><a href="#ref-9">[9]</a></tt> that is a
subset of SGML, the Standard Generalized Markup Language <tt><a href="#ref-37">[37]</a></tt>.
The World Wide Web Consortium (W3C) designed XML to be lightweight and
simple, while retaining compatibility with SGML.  Although HTML
(HyperText Markup Language) is currently the standard web document
language, the W3C is positioning XML to be its replacement.  While HTML
permits authors to use only a pre-determined fixed set of tags in
marking up their document, XML allows easy specification of user-defined
markup tags adapted to the document and data at
hand <tt><a href="#ref-27">[27]</a><a href="#ref-28">[28]</a></tt>.
</p><p>
An XML document consists simply of text marked up with tags enclosed in
angle braces.  A simple example is:
</p>

<pre>
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE email SYSTEM "email.dtd"&gt;
&lt;email&gt;
  &lt;head&gt;
    &lt;to&gt;Mom&lt;/to&gt;
    &lt;to&gt;Dad&lt;/to&gt;
    &lt;from&gt;Greg&lt;/from&gt;
    &lt;subject&gt;My trip&lt;/subject&gt;
  &lt;/head&gt;
  &lt;body encoding="ascii"&gt;
   The weather is terrific!
  &lt;/body&gt;
&lt;/email&gt;
</pre>

<p>
The <code>&lt;email&gt;</code> is an open tag for the <code>email</code> element.
The <code>&lt;/email&gt;</code> at the end of the example is the corresponding
close tag.  Text and other nested tags can appear between the open and
close constructs. Empty elements are allowed and can be abbreviated with
a specialized form that combines the open and close tags:
<code>&lt;<em>tag-name</em></code>/&gt;.  In the above document, the
<code>email</code> element contains two immediate children elements: a
<code>head</code> and a <code>body</code>.  Additionally, an XML open tag
can associate attribute/value pairs with an element.  For example, the
<code>body</code> element above has the value <code>ascii</code> for its
<code>encoding</code> attribute.  For an XML document to be
<em>well-formed</em>, the document must simply conform to the numerous
syntactic rules required of XML documents (e.g., tags must be balanced
and properly nested, attribute values must be of the proper form and
enclosed in quotes, etc.).
</p><p>
A more stringent characterization of an XML document is <em>validity</em>.
An XML document is valid if and only if it both is well-formed and
adheres to its specified <em>document type definition</em>, or <em>DTD</em>.
A document type definition is a formal description of the grammar of the
specific language to be used by a class of XML documents.  It defines
all the permitted element names and describes the attributes that each
kind of element may possess. It also restricts the structure of the
nesting within a valid XML document.  The preceding XML example is valid
with respect to the following DTD:
</p>

<pre>
&lt;!-- email DTD --&gt;
&lt;!ENTITY % encoding-attribute 
  "encoding (ascii|mime) #REQUIRED"&gt;
&lt;!ELEMENT email (head,body)&gt;
&lt;!ELEMENT head (to+,from,subject?)&gt;
&lt;!ELEMENT to (#PCDATA)&gt;
&lt;!ELEMENT from (#PCDATA)&gt;
&lt;!ELEMENT subject (#PCDATA)&gt;
&lt;!ELEMENT body (#PCDATA)&gt;
&lt;!ATTLIST body
    encrypted (yes|no) #IMPLIED
    %encoding-attribute;&gt;
</pre>

<p>
According to this DTD, there are six element types. The <code>email</code>
element must contain exactly one <code>head</code> followed by exactly one
<code>body</code> element.  The <code>head</code>, in turn, must contain one
or more <code>to</code> elements and then a <code>from</code> element,
followed by an optional <code>subject</code> element.  The order of the
elements must be as specified. Each of those
elements may contain text (also know as <em>parsed character data</em> or
<code>PCDATA</code>).  The single <code>ATTLIST</code> declaration in the
DTD specifies that the <code>body</code> element <em>may</em> specify a
value for the <code>encrypted</code> attribute, and <em>must</em> specify
either <code>ascii</code> or <code>mime</code> for the <code>encoding</code>
attribute. The <code>ENTITY</code> declaration of the
<code>encoding-attribute</code> (at the top of the DTD) is a simple way to
factor out redundant text &#151; the text given between the quotes is
substituted as is into the following <code>ATTLIST</code> declaration
(and, importantly, can be used in multiple <code>ATTLIST</code>s).
</p><p>
An XML document that is declared to adhere to this DTD is not valid if
any of the above criteria are not met.  For example, if the
<code>from</code> element is missing from an <code>email</code> document, that
document is not valid, though it may still be well-formed.
</p><p>
When modeling data in XML, a primary design decision is choosing whether
to nest elements or to use attributes.  In the above example, we could
have folded all of the information contained in the <code>head</code> into
attributes of the <code>email</code> element if we chose.  There are
several important differences between using attributes and nesting
elements:
</p>

<ul>

<li> attributes/value pairs are unordered, while nested children have a
specific order;

<li> values for attributes may contain only character data, and may not
      include other markup, while nested children can arbitrarily nest
      further; and
      
<li> only one value for an attribute can be given, while multiple
      elements of the same class can be included by a parent element
      (e.g., we can have multiple <code>to</code> elements contained by
      the <code>head</code>).

</ul>

<p>
Although the above distinctions sometimes mandate using one technique or
the other, the decision is often initially a matter of taste.  However,
later experiences using the resulting documents may suggest revisiting
the decision in order to facilitate or simplify some desired
manipulation of the document.
</p><p>
Another useful data modeling feature of XML is the ability to attach
unique identifiers to elements via an <code>id</code> attribute.  These
elements can then be referred to by <code>idref</code> attributes of other
elements.  A well-formed XML document must have every <code>idref</code>
value match an <code>id</code> given in the document.  The
<code>id</code>&#151;<code>idref</code> links describe edges that enable XML to
represent generalized directed graphs, not just trees.
</p><p>
XML, in part due to its SGML heritage, is very well supported by tools
such as Emacs editing modes, structure-based editors, DTD parsers and
editors, validation utilities, querying systems, transformation and
style languages, and many more tools.  Numerous other W3C
recommendations relate to XML including Cascading Style
Sheets <tt><a href="#ref-8">[8]</a></tt>, XSL (Extensible Stylesheet Language) <tt><a href="#ref-19">[19]</a></tt>,
XSLT (XSL for Transformations) <tt><a href="#ref-14">[14]</a></tt>, XPath <tt><a href="#ref-16">[16]</a></tt>, and DOM
(Document Object Model) <tt><a href="#ref-2">[2]</a></tt>.
</p>

<p><span class="index"><a href="#top">[top]</a>

<h3><a name="javaml">3 - Java Markup Language (JavaML)</a></h3>

<p>
The Java Markup Language provides a complete self-describing
representation of Java source code.  Unlike the conventional
character-based representation of programs, JavaML reflects the
structure of the software artifact directly in the nesting of elements
in the XML-based syntax.  Additionally, it represents extra edges in the 
program graph using the <code>id</code> and <code>idref</code> linking
capabilities of XML.
</p><p>
Because XML is a text-based representation,
many of the advantages of the classical source representation remain.
Because JavaML is an XML application, it is easy to parse, and all
existing tools for working with XML can be applied to Java source code
in its JavaML representation.  JavaML tools can leverage the existing
infrastructure and exploit the canonical representation to improve
their inter-operability.
</p>

<h4><a name="approaches">3.1 - Possible approaches</a></h4>
<p>
Although the basic approach of using an XML application to model source
code is fairly straightforward, there is a large design space for
possible markup languages.  The most obvious possibility is to simply
use XML as a textual dump format of a typical abstract syntax tree
derived from parsing source code.  Consider the simple Java program:
</p>

<pre>
import java.applet.*;
import java.awt.*;

public class FirstApplet 
                   extends Applet {
  public void paint(Graphics g) {
    g.drawString("FirstApplet", 25, 50);
  }
}
</pre>

<p>
Performing the obvious (but very unsatisfying) translation from the AST
of the above might result in the below XML <em>for just the first line
  of code</em>:
</p>

<pre>
&lt;compilation-unit&gt;
 &lt;ImportDeclarationsopt&gt;
  &lt;ImportDeclarations&gt;
   &lt;ImportDeclaration&gt;
    &lt;TypeImportOnDemandDeclaration&gt;
      import
      &lt;Name&gt;
       &lt;QualifiedName&gt;
        &lt;Name&gt;
         &lt;SimpleName&gt;java&lt;/SimpleName&gt;
        &lt;/Name&gt;
        .
        &lt;Name&gt;
         &lt;SimpleName&gt;applet&lt;/SimpleName&gt;
        &lt;/Name&gt;
       &lt;QualifiedName&gt;
      &lt;/Name&gt;
       . * ;
    &lt;/TypeImportOnDemandDeclaration&gt;
   &lt;/ImportDeclaration&gt;
  &lt;/ImportDeclarations&gt;
 &lt;/ImportDeclarationsopt&gt;
...
&lt;/compilation-unit&gt;
</pre>

<p>
Certainly this translation is far from ideal: it is unacceptably
verbose and exposes numerous uninteresting details of the underlying
grammar that was used to parse the classical source
representation.  
</p><p>
An alternate possibility is to literally mark-up the Java source program
without changing the text of the program (i.e., to only add tags).  This
approach might convert the <code>FirstApplet.java</code> implementation
to:
</p>

<pre>
&lt;java-source-program&gt;
&lt;import-declaration&gt;import java.applet.*;
   &lt;/import-declaration&gt;
&lt;import-declaration&gt;import java.awt.*;
   &lt;/import-declaration&gt;

&lt;class-declaration&gt;
&lt;modifiers&gt;public&lt;/modifiers&gt; class 
   &lt;class-name&gt;FirstApplet&lt;/class-name&gt; 
     extends 
      &lt;superclass&gt;Applet&lt;/superclass&gt; {
 &lt;method-definition&gt;
  &lt;modifiers&gt;public&lt;/modifiers&gt;
        &lt;return-type&gt;void&lt;/return-type&gt; 
    &lt;method-name&gt;paint&lt;/method-name&gt;
      (&lt;formal-arguments&gt;
          &lt;type&gt;Graphics&lt;/type&gt; 
          &lt;name&gt;g&lt;/name&gt;
        &lt;/formal-arguments&gt;) 
    &lt;statements&gt;{
    g.drawString("FirstApplet", 25, 50);
  } &lt;/statements&gt;
 &lt;/method-definition&gt;
}
&lt;/class-declaration&gt;
&lt;/java-source-program&gt;
</pre>

<p>
This format is a huge step towards a more useful markup language.  We
have definitely added value to the source code and it is trivial to
convert back to the classical representation: we simply remove all tags
and leave the content of the elements behind (this removal of markup is
exactly what the <code>stripsgml</code> <tt><a href="#ref-31">[31]</a></tt> utility does).
Although this representation seems useful for many tasks, it still has
some problems.  First, many of the details of the code are included in
the textual content of elements.  If we want to determine what packages
are being imported, our XML query would need to lexically analyze the
content of the import-declaration elements.  Such analysis is
inconvenient and does not take advantage of the capabilities that XML
provides.  Perhaps more significantly, the above XML representation
retains artifacts from the classical source code that another
representation might permit us to abstract away from and free ourselves
of those syntactic burdens altogether.
</p>

<h4><a name="chosen-representation">3.2 - The chosen representation</a></h4>

<p>
The prototype JavaML representation I have chosen aims to model the
programming language constructs of Java (and, indeed, similar
object-oriented programming languages) independently of the specific
syntax of the language.  One can easily imagine a SmalltalkML that would
be very similar, and even an OOML that could be converted into both
classical Java source code or Smalltalk file-out format.  With this goal
in mind, JavaML was designed from first principles of the constructs and
then iteratively refined to improve the usefulness and readability of
the resulting markup language.
</p><p>
JavaML is defined by the document type definition (DTD) in
<a href="#javaml-dtd">appendix A</a>, but is best illustrated by example.  For the
<code>FirstApplet.java</code> source code listed above, we represent the
program in JavaML as shown below.
</p>

<a name="fig-firstapplet-converted"><p class="caption">FirstApplet.java converted to JavaML.</p></a>
<pre>
   1  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   2  &lt;!DOCTYPE java-source-program SYSTEM "java-ml.dtd"&gt;
   3  
   4  &lt;java-source-program name="FirstApplet.java"&gt;
   5    &lt;import module="java.applet.*"/&gt;
   6    &lt;import module="java.awt.*"/&gt;
   7    &lt;class name="FirstApplet" visibility="public"&gt;
   8      &lt;superclass class="Applet"/&gt;
   9      &lt;method name="paint" visibility="public" id="meth-15"&gt;
  10        &lt;type name="void" primitive="true"/&gt;
  11        &lt;formal-arguments&gt;
  12           &lt;formal-argument name="g" id="frmarg-13"&gt;
  13               &lt;type name="Graphics"/&gt;&lt;/formal-argument&gt;
  14        &lt;/formal-arguments&gt;
  15        &lt;block&gt;
  16          &lt;send message="drawString"&gt;
  17            &lt;target&gt;&lt;var-ref name="g" idref="frmarg-13"/&gt;&lt;/target&gt;
  18              &lt;arguments&gt;
  19                &lt;literal-string value="FirstApplet"/&gt;
  20                &lt;literal-number kind="integer" value="25"/&gt;
  21                &lt;literal-number kind="integer" value="50"/&gt;
  22              &lt;/arguments&gt;
  23          &lt;/send&gt;
  24        &lt;/block&gt;
  25      &lt;/method&gt;
  26    &lt;/class&gt;
  27  &lt;/java-source-program&gt;
</pre>
<p class="caption"><strong>Figure 1</strong> &#151; FirstApplet.java converted to JavaML.</p>

<p>
In JavaML, concepts such as methods, superclasses, message
sends, and literal numbers are all directly represented in the elements
and attributes of the document contents.  The representation reflects the
structure of the programming language in the nesting of the elements.
For example, the literal string <code>"FirstApplet"</code> is a part of the message
send, thus the <code>literal-string</code> element is nested inside the
<code>send</code> element.  This nesting is even more apparent when
presented visually as in figures <a href="#fig2a">1a</a> and <a href="#fig2b">1b</a>.
See the author's <a href="http://www.cs.washington.edu/homes/gjb/JavaML">JavaML web page </a><tt><a href="#ref-4">[4]</a></tt>
for further examples.
</p><p>
The careful reader will observe that the JavaML representation is about
three times longer than the classical source code.  That expansion is a
fundamental tradeoff of moving to a self-describing data format such as
XML.  It is important that the terse classical representation can be
employed by programmers in certain tasks including ordinary development
and program editing (though perhaps JavaML may be the underlying
representation).  JavaML is complementary to classical source
code and is especially appropriate for tools while remaining
accessible to and directly readable by developers.
</p>

<p class="caption">
<a name="fig2a"><IMG ALT="XML Notepad's Tree view of FirstApplet's JavaML Representation." SRC="./treevw1.gif" ALIGN="bottom"></a>
<a name="fig2b"><IMG ALT="XML Spy's Tree view of FirstApplet's JavaML Representation." SRC="./treevw2.gif" ALIGN="bottom"></a><br>

<strong>Figure 2</strong> &#151; Tree views of the JavaML representation 
of the <code>FirstApplet</code> example as displayed by the 
XML Notepad utility <tt><a href="#ref-44">[44]</a></tt> (on the left/above) and XML Spy <tt><a href="#ref-36">[36]</a></tt> (on the 
right/below)
</p>


<h4><a name="design-decisions">3.3 - Design decisions</a></h4>

<p>
JavaML provides more than just the structure of the source program.
In <a href="#fig-firstapplet-converted">figure 1</a>,
notice the use of the formal-argument
<code>g</code> in line 17 as the target of the message send.  The
<code>idref</code> attribute of that <code>var-ref</code> tag points back at
the referenced <code>formal-argument</code> element (through its
<code>id</code> attribute).  (The <code>id</code> value chosen for a
to-be-referenced element must be unique within a document so each
identifier is branded with an integer to keep the values distinct.)
This linking is standard XML, thus XML tools are able to trace from a
variable use to its definition to, e.g., obtain the type of the
variable.  Similar linking is done for local (block-declared) variables, 
and more could be done for other edges in the program structure graph.
Although a single <code>var-use</code> tag would suffice for denoting any
mention of a variable, JavaML instead disambiguates between references to
variable values and variables used as lvalues: <code>var-ref</code>
elements are used for the former, <code>var-set</code> for the latter.
</p><p>
Throughout JavaML, attributes of elements are used whenever the
structure of the value can never be more complex than a simple text
string.  Attributes are used for modifiers such as
<code>synchronized</code> and <code>final</code> and for visibility settings
such as <code>public</code> or <code>private</code>.  Attributes are not
used for properties such as types because types have some structure: a
type can consist of a base name and a number of dimensions, and it could
also reference the definition of the class that implements the type, if
desired.  If, say, a return type were just the value of an attribute on
the method element, the end user would unacceptably have to do string
processing on the attribute's value "<code>int[][]</code>" to determine
that the base type of that two-dimensional array was the primitive type
<code>int</code>.  Instead, types are modeled as explicit child elements
such as <code>&lt;type name="int" dimensions="2"&gt;</code>.
</p><p>
JavaML generalizes related concepts to simplify some analyses but also
preserves distinctions that may be needed for other tasks.  For example,
<code>45</code> and <code>1.9</code> are represented as:
<code>&lt;literal-number kind="integer" value="45"&gt;</code> and
<code>&lt;literal-number kind="float" value="1.9"&gt;</code>, respectively.  An
alternate possible markup is: <code>&lt;literal-integer value="45"&gt;</code>
and <code>&lt;literal-float value="1.9"&gt;</code> but using separate element
classes eliminates the tight relationship that both values are numbers
and can complicate using the representation.  Instead, we use a single
element tag and disambiguate these literals based on a <code>kind</code>
attribute. Thus, we can still tell the difference between a floating
point literal and an integer literal, but in the common case we gain the
same flexibility of numeric types that the Java language has.
</p><p>
Another place where JavaML generalizes language constructs is loops.
Both <code>for</code> and <code>while</code> loops can be viewed as general
looping constructs with 0 or more initializers, a guarding test that
occurs before each iteration, 0 or more update operations, and a body of
statements that comprise the looped-over instructions.  Thus, instead of
using two classes of elements, <code>for-loop</code> and
<code>while-loop</code>, JavaML uses a single <code>loop</code> element that
has a <code>kind</code> attribute with value either <code>for</code> or
<code>while</code>.  When a <code>while</code> loop is converted, it will
have neither <code>initializer</code> nor <code>update</code> children, yet
a <code>for</code> loop could potentially contain many of each.  In
contrast, distinct <code>do-loop</code> elements are used for
<code>do</code> loops because they have their test performed at the end of
the loop, instead of at the start.
</p><p>
As yet another example, we represent both instance and class (i.e.,
static) fields as <code>field</code> elements with a <code>static</code>
attribute used to disambiguate.  Although there are more substantial
differences between these two concepts than between <code>while</code>
and <code>for</code> loops, it still seems beneficial to use a single
kind of element for both kinds of fields.
</p><p>
Local variable declarations provide a syntactic shorthand that raises an
interesting question about their underlying representation.  The code
segment <code>int dx, dy;</code> defines two variables both of type
<code>int</code>, but with perhaps a subtle additional intention: that the
two variables have the same type.  For contrast, consider <code>int
  weight, i;</code>.  Here, there probably is <em>not</em> the implicit desire
that the two variables have the same type, but instead the shorthand
syntax is being used simply for brevity.  Because it is hard to automate
distinguishing these cases, JavaML simply preserves this syntactic
feature by using a <code>continued="true"</code> attribute on variable
declarations that exploit this shorthand.
</p><p>
Comments in source code are especially troublesome to deal with in
JavaML.  At present, the DTD permits certain "important" elements
(including <code>class</code>, <code>anonymous-class</code>,
<code>interface</code>, <code>method</code>, <code>field</code>,
<code>block</code>, <code>loop</code>) to specify a <code>comment</code>
attribute.  Determining which comments to attach to which elements is
challenging; the current implementation simply queues up comments and
includes all that appear since the last "important" element in the
<code>comment</code> attribute of the current such element.
</p><p>
An alternate possibility for comments is to just insert them in the
JavaML representation as parsed character data interspersed with the
normal structure, thus leaving the semantic inference problem to another
tool.  Unfortunately, this would force various elements to have "mixed
content" which reduces the validation capabilities when checking for
DTD conformance.  Using XML Schema <tt><a href="#ref-51">[51]</a></tt> instead of DTDs may
make this approach more useful.
</p>


<h4><a name="implementation">3.4 - Implementation of converter</a></h4>

<p>
To experiment with the design of JavaML and gain experience in using the
representation, it was essential to implement a converter from the Java
classical source representation to JavaML.  Within the IBM Jikes Java
compiler framework <tt><a href="#ref-32">[32]</a></tt>, I added an <code>XMLUnparse</code> method
to each of the AST nodes. This change, along with some small additional
code for managing the options to request the XML output, results in a
robust and fast JavaML converter.  In total, I added about 1650
non-comment-non-blank lines of C++ code to the Jikes framework to
support JavaML.
</p><p>
The converter has been tested by converting 15,000 lines of numerous
sample programs including the 4300 line Cassowary Constraint Solving
Toolkit <tt><a href="#ref-5">[5]</a></tt> and over twenty diverse applets <tt><a href="#ref-50">[50]</a></tt>.  Each of
the files converted was then validated with respect to the JavaML DTD
using James Clark's Jade package's <code>nsgmls</code> tool <tt><a href="#ref-12">[12]</a></tt>.
The processing of the entire regression test takes only about twelve
seconds on the author's RedHat6-based dual Pentium III-450 machine.
</p><p>
Also implemented is an XSLT stylesheet that outputs the classical source
representation given the JavaML representation. The style sheet consists
of 65 template rules and just under 600 lines of code.  It was tested
(using both Saxon <tt><a href="#ref-39">[39]</a></tt> and XT <tt><a href="#ref-15">[15]</a></tt>) on numerous programs
by processing a file to JavaML, back-converting it, and then
re-converting to JavaML: no differences should exist between the result
and the originally-converted JavaML file.
</p><p>
All of the source code is available from the JavaML home
page <tt><a href="#ref-4">[4]</a></tt>.
</p>

<p><span class="index"><a href="#top">[top]</a></span></p>

<h3><a name="leveraging-xml">4 - Leveraging XML</a></h3>

<p>
JavaML uses XML as an alternate, structured representation of a Java
source program.  Although the abstraction away from syntactic details of
Java is convenient, the more important benefit is that JavaML enables
the use of the rich infrastructure developed to support SGML and XML.
Instead of building analysis and transformation tools from scratch to
work on a proprietary binary structured format for a program, existing
SGML and XML tools can be used, combined, and extended.  XML tools
encompass a broad range of features that include querying and
transformation, document differencing and merging <tt><a href="#ref-33">[33]</a></tt>,
and simple APIs for working with the document directly.  In this paper,
I will (for space reasons) limit discussion to uses of only three tool
groups:
</p>

<ul>
<li> the XML toolbox (ltxml) from Edinburgh University <tt><a href="#ref-52">[52]</a></tt>
which contains <code>sgcount</code>,
<code>sgrpg</code>, <code>sggrep</code>, and more;

<li> XSLT <tt><a href="#ref-14">[14]</a></tt> processors (e.g., XT <tt><a href="#ref-15">[15]</a></tt> and Saxon <tt><a href="#ref-39">[39]</a></tt>)
      and the XML parser XP <tt><a href="#ref-13">[13]</a></tt>;

<li> the Perl XML::DOM package <tt><a href="#ref-20">[20]</a></tt> which exposes a
DOM level 1 <tt><a href="#ref-2">[2]</a></tt> interface to an XML tree.
</ul>

<p>
These are just a very small subset of the tools that prove useful when
working with JavaML.  In the following examples, we will query
<code>Hangman.java.xml</code>, the JavaML representation of the Hangman
applet available at Sun Microsystems' applet page <tt><a href="#ref-50">[50]</a></tt> and
also at the JavaML home page <tt><a href="#ref-4">[4]</a></tt>.  Although these examples
are small by real-world standards, XML and SGML tools target documents
ranging up through lengthy books so the implementations are designed to
scale well.
</p><p>
One common software engineering task (for better or for worse) is to
accumulate metrics about a source code artifact.  With JavaML, the SGML
utility <code>sgcount</code> does an excellent job of summarizing the
constructs in a Java program:  (The output of commands has been
  pruned and slightly edited for presentation.)
</p>

<pre>
% sgcount Hangman.java.xml
</pre>

<em>outputs:</em>

<pre>
arguments             103
array-initializer     4
assignment-expr       60
catch                 3
class                 1
if                    27
true-case             27
false-case            7
field                 28
field-access          18
import                5
java-source-program   1
literal-char          5
literal-boolean       5
literal-null          5
literal-number        127
literal-string        61
local-variable        23
loop                  13
method                18
new                   4
new-array             5
return                5
send                  99
type                  96
var-ref               262
var-set               52
...
</pre>

<p>
In the above output, each row lists an element class and the number of
times that that element appeared in the document.  Thus, we can easily
see that there are 18 <code>method</code> elements, thus there are 18
method definitions.  Similarly, we can see that there is 1 class
definition, 262 variable references, 99 message sends, and 61 string
literals.  This summary is far more indicative of the content of a
program than a typical lexical measure such as the number of lines of
code.
</p><p>
Suppose we wish to see all the string literals that a program contains.
We can do this trivially using <code>sggrep</code> on the JavaML
representation of the program:

<pre>
% sggrep '.*/literal-string' &lt; Hangman.java.xml
</pre>

<em>outputs:</em>
<pre>
&lt;literal-string value='audio/dance.au'/&gt;
&lt;literal-string value='img/dancing-duke/T'/&gt;
&lt;literal-string value='.gif'/&gt;
&lt;literal-string value='img/hanging-duke/h'/&gt;
&lt;literal-string value='.gif'/&gt;
&lt;literal-string value='Courier'/&gt;
&lt;literal-string value='Courier'/&gt;
...
</pre>

Notice that the output of <code>sggrep</code> is also a (not necessarily
valid nor even well-formed) XML document.  Thus we can string together
SGML and XML tools in a Unix pipeline to combine tools in novel and
useful ways.  For example, it is sometimes worthwhile to convert results back into
ordinary Java source representation to aid the human software-engineer.
We can do this using <code>results-to-plain-source</code> which is a
wrapper around an XSLT stylesheet that converts JavaML back into
plain source code:
</p>

<pre>
% sggrep '.*/literal-string' &lt; Hangman.java.xml | results-to-plain-source
</pre>

<em>outputs:</em>
<pre>
"audio/dance.au"
"img/dancing-duke/T"
".gif"
"img/hanging-duke/h"
".gif"
"Courier"
"Courier"
...
</pre>

<p>
We can also query the JavaML source for elements based on values of
their attributes.  For example, if we wish to find all sends of the
message <code>setFont</code> we can do so easily and precisely:

<pre>
% sggrep '.*/send[message=setFont]' &lt; Hangman.java.xml 
</pre>

<em>outputs:</em>
<pre>
&lt;send message='setFont'&gt;
  &lt;target&gt;
   &lt;var-ref name='g' idref='frmarg-212'/&gt;
  &lt;/target&gt;
  &lt;arguments&gt;
   &lt;var-ref name='font' idref='locvar-611'/&gt;
  &lt;/arguments&gt;
&lt;/send&gt;
&lt;send message='setFont'&gt;
  &lt;target&gt;
   &lt;var-ref name='g' idref='frmarg-212'/&gt;
  &lt;/target&gt;
  &lt;arguments&gt;
   &lt;var-ref name='wordFont'/&gt;
  &lt;/arguments&gt;
&lt;/send&gt;
</pre>

Because of the structural markup, places where the seven characters
"setFont" appear in a comment, a literal string, or a variable name
will <em>not</em> be reported by this query.  A similar attempt to
retrieve this information using lexical tools would likely contain those
false positives.  Imagine trying to find all type cast expressions using 
only lexical tools &#151; the over-use of parentheses in Java expressions
make that task very difficult, while it is trivial with JavaML thanks to 
the <code>cast-expr</code> element.
</p><p>
Another class of common analyses is the semantic checks done by the
compiler prior to translation.  For example, in Java code, only abstract
classes may have abstract methods.  When compiling, a semantic error
will be flagged if this rule is violated.  We can query a JavaML document
for concrete (i.e., not abstract) classes that contain an abstract method:

<pre>
% sggrep -q '.*/class[abstract!=true]/method[abstract=true]' &lt; Hangman.java.xml
</pre>

and the output will be empty because this semantic restriction is not
violated in our target document (i.e., the analyzed program).
</p><p>
A common error for novice Java programmers is to accidentally use the
assignment operator, <code>=</code>, instead of using the equality test
operator, <code>==</code>.  Although the Java type checker will catch
most of these errors at compile time, it will miss the problem if
the assigned-to variable is a <code>boolean</code>. If we wish to find these
questionable constructs, <code>sggrep</code> makes this analysis
trivial thanks to the JavaML representation:
</p>

<pre>
% sggrep -q '.*/if/test/assignment-expr' &lt; Hangman.java.xml
</pre>

<p>
The <code>sgrpg</code> (SGML RePort Generator) program permits combining a
top-level query with a restriction on the children and an output format
for the results (a common paradigm for querying tools <tt><a href="#ref-24">[24]</a></tt>).
For example:

<pre>
% sgrpg '.*/method' '.*/send[message=drawLine]' '' '%s %s 
' visibility name &lt; Hangman.java.xml
</pre>

<em>outputs:</em>
<pre>
public paint
</pre>

searches for method definitions that contain message sends of the
message <code>drawLine</code>.  It then outputs the
<code>visibility</code> and <code>name</code> attributes of the matched
elements as shown above, confirming our intuition that the
<code>paint()</code> method is the only function that invoked <code>drawLine</code>.
</p><p>
A wide variety of analyses are possible just using the querying
capabilities provided by standard XML tools.  Other things we can find
are returns from inside for loops, all definitions of integer variables,
string variables that do not conform to our project's naming convention,
and much more.
</p><p>
The preceding queries illustrate a shortcoming of current XML querying
tools: most respond only with the matched elements  &#151; they do not provide
any context information about where in the document the results were
found.  Although this behaviour is appropriate when treating an XML file
strictly as a database, the software engineer may want to know where the
results were in the JavaML file to then map them back into positions in
the source document for editing or viewing by hand.  I address this
difficulty in JavaML by attaching information about the original
source-code location of constructs as attributes of various elements.
The location information includes the starting and ending line and
column numbers of the construct (the filename is found in the ancestor
<code>java-class-file</code> element).
</p><p>
In addition to queries, transformations on source
code are very useful when modifying and
evolving software artifacts.  Querying tools generally only prune
elements from the source document or combine elements from multiple
documents.  More powerful transformations are possible using
XSLT <tt><a href="#ref-14">[14]</a></tt>, DSSSL <tt><a href="#ref-38">[38]</a></tt>, or directly manipulating the
document using a DOM (Document Object Model) <tt><a href="#ref-2">[2]</a></tt> interface
accessible from numerous languages including Perl, Python, Java, and
C++.  For example, we can rename all methods named <code>isBall</code> to
<code>FIsBall</code> using a straightforward XSLT stylesheet:

<pre>
&lt;xsl:stylesheet ......&gt;

&lt;xsl:param name="oldname"/&gt;
&lt;xsl:param name="newname"/&gt;

&lt;!-- mostly do an identity transform --&gt;
&lt;xsl:template match="*|@*|text()"&gt;
 &lt;xsl:copy&gt;
  &lt;xsl:apply-templates select="*|@*|text()"/&gt;
 &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="method[@name=$oldname]"&gt;
 &lt;method name="{$newname}"&gt;
  &lt;xsl:apply-templates/&gt;
 &lt;/method&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="send[@message=$oldname]"&gt;
 &lt;send message="{$newname}"&gt;
  &lt;xsl:apply-templates/&gt;
 &lt;/send&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre>

and executing it like so:
</p>

<pre>
xt source.java.xml method-rename.xsl oldname=isBall newname=FIsBall
</pre>

<p>
While a similar textual transformation could be performed using a text
editor or Sed, those tools will over-aggressively change all occurrences
of the six character sequence <code>isBall</code>. Variable names, literal
strings, comments, and packages might incorrectly be affected by the
text-based transformation. This is a key benefit of the JavaML
representation: we have more fine-grained, semantically-based control
over the affected constructs.
</p><p>
Other possibilities for transformations include using a style sheet to output a
browse-able HTML representation of the program (see <a href="#fig3">figure 3</a>)
or syntax-highlighted PostScript.  Adding debug or instrumentation code at entry and
exit to and from functions is also straightforward (see <a href="#fig4">figure 4</a>).
</p>

<p class="caption">
<a name="fig3">
<IMG ALT="HTML Pretty-printed Screenshot of Hangman.java.xml" SRC="./ie-html.gif"></a><br>
<strong>Figure 3</strong> &#151; A view of Hangman.java.xml processed by an XSLT HTML pretty-printer and
indexer.  The method index links to the start of the definition of each method, and 
syntax highlighting is done using color-coding and italics.
</p>


<a name="fig4">&nbsp;</a>
<pre>
#!/usr/bin/perl -w
use XML::DOM;
use IO::Handle;

my $filename = shift @ARGV;

my $parser = new XML::DOM::Parser;
my $doc = $parser-&gt;parsefile ($filename);

my $nodes = $doc-&gt;getElementsByTagName("method");

for (my $i = 0; $i &lt; $nodes-&gt;getLength(); $i++) {
  my $method = $nodes-&gt;item($i);
  my $block = $method-&gt;
    getElementsByTagName("block")-&gt;item(0);
  my $name = $method-&gt;getAttribute("name");

  my $start_code
    = SendMessageBlock($doc,"Tracer","StartMethod",
                       $name);
  my $exit_code 
    = SendMessageBlock($doc,"Tracer","ExitMethod",
                       $name);

  $block-&gt;insertBefore($start_code,
                       $block-&gt;getFirstChild());
  $block-&gt;appendChild($exit_code);
}
print $doc-&gt;toString;

sub SendMessageBlock {
  my ($doc,$target_var,$method_name,$data) = (@_);
  # insert, e.g:  Tracer.StartMethod("paint");
 return parseXMLFragment($doc,&lt;&lt;"__END_FRAGMENT__"
</pre>

<p class="caption">
<strong>Figure 4</strong> &#151;
Perl program to instrument every method of a Java class with invocations of
  <code>Tracer.StartMethod(<em>method_name</em>)</code> and
  <code>Tracer.ExitMethod(<em>method_name</em>)</code>.  The
  program uses the Document Object Model (DOM) <tt><a href="#ref-2">[2]</a></tt> Perl
  module <tt><a href="#ref-20">[20]</a></tt>.
</p>


<p><span class="index"><a href="#top">[top]</a></span>

<h3><a name="related-work">5 - Related work</a></h3>

<p>
A key benefit of JavaML is its ability to leverage the growing
infrastructure of SGML and XML related tools and techniques as described
in the previous section.  Various researchers have similarly approached
the problem of improving software engineering and development tools with
varying degrees of success.
</p><p>
TAWK <tt><a href="#ref-29">[29]</a></tt> extends the AWK <tt><a href="#ref-21">[21]</a></tt> paradigm by matching
patterns in the AST of a C program.  Numerous XML querying tools provide
this same functionality for JavaML, and the event-action framework is
similar to that used by SAX (Simple API for XML) <tt><a href="#ref-43">[43]</a></tt>.
</p><p>
ASTLog <tt><a href="#ref-18">[18]</a></tt> extends the Prolog <tt><a href="#ref-17">[17]</a></tt> logic programming
language with the ability to reason about an external database that
models the AST.  Unlike Prolog, ASTLog statements are evaluated with
respect to a current object.  The approach that Crew uses may be
interesting to apply to the XML world, but the numerous XML tools
already provide comparable functionality through a more conventional (if
perhaps less convenient) framework.
</p><p>
GRAS <tt><a href="#ref-40">[40]</a></tt> is a graph-oriented database system for software engineering
environments.  Front-ends are available for integrating source-code from
ordinary representation of C, Modula-3, and Modula-2 into the database.  The database 
approach may prove useful for storing XML, especially in the context of
the software-engineering applications for which JavaML is designed.
</p><p>
The Software Development Foundation <tt><a href="#ref-46">[46]</a></tt> is an open
architecture based on XML designed for developing tools for programming
environments.  An XML database format called
CSF &#151; code structure format &#151; stores relationships, but includes no
details about the computation performed.  Chava <tt><a href="#ref-41">[41]</a></tt> takes a
similar approach, but is based on the C Program Database <tt><a href="#ref-11">[11]</a></tt>.
Chava also permits interrogating Java code via reverse
engineering the byte-codes.
</p><p>
CCEL <tt><a href="#ref-22">[22]</a></tt> provides a metalanguage for expressing non-linguistic
intentions (i.e., ones that cannot be expressed in the language) about
software artifacts written in C++.  JavaML can provide a similar
capability by simply writing queries that search for violations of the
intended invariants and reporting them as part of the edit, build, or
regression-test procedure throughout the development cycle.
</p><p>
Microsoft's Intentional Programming group <tt><a href="#ref-47">[47]</a></tt> has long been
working on a more abstract representation of computation that is
syntax-independent.  Their goal appears to be to permit developers to
describe new abstractions along with techniques to reduce those
abstractions down to known primitives.  In essence, they are interested
in permitting the developer to grow a domain-specific language as they
build their software.  JavaML is especially exciting as a representation
for this approach.  We can view new abstractions as incremental
extensions to DTDs.  In order for the new document type, call it
Java++ML, to still be compilable by a stock Java compiler, the developer
must simply write a transformation from Java++ML to JavaML.  Because
DTDs are exceptionally easy to extend, this approach is tenable and
likely a fruitful avenue for future work.  There are several utilities
for documenting and comparing DTDs (e.g., <code>dtd2html</code> and
<code>dtddiff</code> of the perlSGML package <tt><a href="#ref-31">[31]</a></tt>) that would
be helpful when applying this technique.
</p>

<p><span class="index"><a href="#top">[top]</a></span>

<h3><a name="future-work">6 - Future work</a></h3>

<p>
Although this paper has presented a markup language for Java, the same
basic approach can be applied to other programming languages, or even to
translate among languages.  To the extent that the representation
abstracts away syntax, JavaML may also prove useful in permitting the
import of visual representations such as Unified Modeling Language
diagrams <tt><a href="#ref-1">[1]</a><a href="#ref-35">[35]</a></tt>.  Certainly generating visual
representations of important properties of software artifacts is on the
immediate horizon given the capabilities of XSL and DSSSL.
</p><p>
One significant complication in applying this approach to C++, another
popular conventional object-oriented-programming language, is the C
preprocessor.  The C preprocessor provides a first pass of textual
processing to permit abstractions that cannot otherwise be expressed in
the core C++ language.  These abstractions are often very important to
the understandability and maintainability of the code, but do not
interact well with parsing techniques <tt><a href="#ref-23">[23]</a><a href="#ref-6">[6]</a></tt>.
</p><p>
A useful extension to the current transformation system is to do
more cross-linking of elements.  Type elements could reference their
defining classes in other JavaML documents.  Import declarations could
reference the top-level documentation for the imported package.  Many
more possibilities are feasible.
</p><p>
The current converter that translates back from JavaML to the classical
source representation is based on XSLT.  Adding a
Jikes front-end would permit the compiler to read JavaML directly.
Such an implementation would use an XML parser (e.g.,
XML4C++ <tt><a href="#ref-34">[34]</a></tt>) to construct the XML DOM from the JavaML source,
then simply recursively build the Jikes internal AST using the DOM API.
Back-conversion to the plain source code could then be done using
Jikes's pre-existing conventional unparser.
</p><p>
Using JavaML as the primary source representation has the potential to
simplify the compiler beyond just eliminating its classical front-end.
Some semantic analyses can be removed from the compiler once it knows
that the input is a valid JavaML document.  It will be useful to
characterize which semantic errors are provably impossible to encounter
given that precondition.  Because XML
Schema <tt><a href="#ref-51">[51]</a><a href="#ref-7">[7]</a></tt> provide an even finer-grained
specification of validity for XML documents, it is likely beneficial to
migrate JavaML to use an them instead of a DTD after the working drafts
are finalized.  Additionally, more semantic analyses can be moved into
the editing environment reasonably painlessly in the form of
straightforward queries (such as some of those described earlier in
<a href="#leveraging-xml">section 4</a>).
</p><p>
Because the concise textual representation of source code is nicely
suited to human programmers, it is unlikely that they will be interested
in discarding their favourite text editor anytime soon.  We must
investigate better ways to convert interactively and incrementally
between the classical source representation and JavaML.  The
capabilities could then be used to transparently support interactive
editing of XML representations using plain-text format to which human
engineers are accustomed.  The considerable work on structured text
editors <tt><a href="#ref-30">[30]</a><a href="#ref-45">[45]</a></tt> is highly relevant and may finally
achieve acceptance give the incredible resources that will now be thrown
at the problem given the growing commercial importance of XML
technology.
</p>

<p><span class="index"><a href="#top">[top]</a></span>

<h3><a name="conclusion">7 - Conclusion</a></h3>

<p>
JavaML is an alternate representation of Java source programs that is
based on XML.  Unlike the classical textual source representation, the
JavaML representation makes it easy for software tools to reason about
programming-level constructs in a Java program.  This benefit results from the
ability of JavaML to more directly represent the structure of the program.
</p><p>
Given JavaML, the wealth of pre-existing XML and SGML tools can perform
numerous interesting and useful analyses and transformations of Java
source programs.  XML tools are improving continually to support the
growing infrastructure of XML-based documents.  Ultimately, JavaML could
replace the classical source representation of Java programs as the
storage format for programs, relegating text-parsing to just one of many
possible ways of interacting directly with the structured representation
of the software artifact throughout the development process.
</p>

<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="acknowledgments">Acknowledgments</a></h3> 
<p>
I enthusiastically thank Zack Ives for his comments, discussion, and
input.  I thank Corin Anderson and Alan Borning for much-appreciated
comments on a draft of this paper.  I also thank Miguel Figueroa,
Karl-Trygve Kalleberg, Craig Kaplan, Todd Millstein, Stig E. Sand&oslash;, and
Stefan Bjarni Sigurdsson for their helpful discussions. Thanks to IBM
for constructing the Jikes compiler framework, and for making it
publicly available, and thanks to Mike Ernst for helpful pointers on
using it. This work was supported by the University of Washington
Computer Science and Engineering Wilma Bradley fellowship and by NSF
Grant No. IIS-9975990.
</p>

<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="javaml-dtd">Appendix A - JavaML DTD</a></h3>
<small>
<pre>
&lt;!-- <a href="http://www.cs.washington.edu/homes/gjb/JavaML/untar/JavaML/java-ml.dtd">java-ml.dtd</a> 0.96 --&gt;
&lt;!-- Copyright (C) 2000, Greg J. Badros &lt;gjb@cs.washington.edu&gt; --&gt;
&lt;!-- A DTD for JavaML, an XML representation of Java Source Code --&gt;
&lt;!-- <a href="http://www.cs.washington.edu/homes/gjb/papers/javaml/javaml.html">http://www.cs.washington.edu/homes/gjb/papers/javaml/javaml.html</a> --&gt;

&lt;!ENTITY % visibility-attribute "visibility (public|private|protected) #IMPLIED"&gt;
&lt;!ENTITY % interface-visibility-attribute "visibility (public) #IMPLIED"&gt;
&lt;!ENTITY % kind-attribute "kind (integer|long|float|double) #IMPLIED"&gt;
&lt;!ENTITY % mod-final "final CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-static "static CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-volatile "volatile CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-transient "transient CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-native "native CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-abstract "abstract CDATA #IMPLIED"&gt;
&lt;!ENTITY % mod-synchronized "synchronized CDATA #IMPLIED"&gt;
&lt;!ENTITY % location-info 
	"line CDATA #IMPLIED col CDATA #IMPLIED 
         end-line CDATA #IMPLIED end-col CDATA #IMPLIED
	 comment CDATA #IMPLIED"&gt;
&lt;!ENTITY % expr-elems "send|new|new-array|var-ref|field-access|array-ref|paren|assignment-expr|conditional-expr|binary-expr|unary-expr|cast-expr|instanceof-test|literal-number|literal-string|literal-char|literal-boolean|literal-null|this|super"&gt;
&lt;!ENTITY % stmt-elems "block|local-variable|try|throw|if|switch|loop|do-loop|return|continue|break|synchronized|%expr-elems;"&gt;

&lt;!ELEMENT code-fragment ANY&gt;
&lt;!ELEMENT result ANY&gt;
&lt;!ELEMENT java-source-program (java-class-file+)&gt;
&lt;!ELEMENT java-class-file (package-decl?,import*,(class|interface)+) &gt;
&lt;!ATTLIST java-class-file
    name CDATA #IMPLIED
    version CDATA #IMPLIED&gt;
&lt;!ELEMENT import EMPTY&gt;
&lt;!ATTLIST import
    module CDATA #REQUIRED&gt;
&lt;!ELEMENT class (superclass?, implement*, (class|interface|constructor|method|field|static-initializer|instance-initializer)*) &gt;
&lt;!ATTLIST class
    name CDATA #REQUIRED
    %visibility-attribute;
    %mod-static;
    %mod-abstract;
    %mod-final;
    %mod-synchronized;
    %location-info;&gt;
&lt;!ELEMENT anonymous-class (superclass?, implement*, (constructor|method|field|instance-initializer)*) &gt;
&lt;!ATTLIST anonymous-class
    %mod-abstract;
    %mod-final;
    %mod-synchronized;
    %location-info;&gt;
&lt;!ELEMENT superclass EMPTY&gt;
&lt;!ATTLIST superclass
    name CDATA #REQUIRED&gt;
&lt;!ELEMENT interface (extend*, (method|field)*) &gt;
&lt;!ATTLIST interface
    name CDATA #REQUIRED
    %interface-visibility-attribute;
    %location-info;&gt;
&lt;!ELEMENT implement EMPTY&gt;
&lt;!ATTLIST implement
    interface CDATA #REQUIRED&gt;
&lt;!ELEMENT extend EMPTY&gt;
&lt;!ATTLIST extend
    interface CDATA #REQUIRED&gt;
&lt;!ELEMENT field (type,(array-initializer|%expr-elems;)?)&gt;
&lt;!ATTLIST field
    name CDATA #REQUIRED
    %visibility-attribute;
    %mod-final;
    %mod-static;
    %mod-volatile;
    %mod-transient;
    %location-info;&gt;
&lt;!ELEMENT constructor (formal-arguments,throws*,(super-call|this-call)?,(%stmt-elems;)?)&gt;
&lt;!ATTLIST constructor
    name CDATA #REQUIRED
    id ID #REQUIRED
    %visibility-attribute;
    %mod-final;
    %mod-static;
    %mod-synchronized;
    %mod-volatile;
    %mod-transient;
    %mod-native;
    %location-info;&gt;
&lt;!ELEMENT method (type,formal-arguments,throws*,(%stmt-elems;)?)&gt;
&lt;!ATTLIST method 
    name CDATA #REQUIRED
    id ID #REQUIRED
    %visibility-attribute;
    %mod-abstract;
    %mod-final;
    %mod-static;
    %mod-synchronized;
    %mod-volatile;
    %mod-transient;
    %mod-native;
    %location-info;&gt;
&lt;!ELEMENT formal-arguments (formal-argument)*&gt;
&lt;!ELEMENT formal-argument (type)&gt;
&lt;!ATTLIST formal-argument
    name CDATA #REQUIRED
    id ID #REQUIRED
    %mod-final;&gt;
&lt;!ELEMENT send (target?,arguments)&gt;
&lt;!ATTLIST send
    message CDATA #REQUIRED
    idref IDREF #IMPLIED&gt;
&lt;!ELEMENT block (label*,(%stmt-elems;)*)&gt;
&lt;!ATTLIST block
    %location-info;&gt;
&lt;!ELEMENT label EMPTY&gt;
&lt;!ATTLIST label
    name CDATA #REQUIRED&gt;
&lt;!ELEMENT target (%expr-elems;)&gt;
&lt;!ELEMENT return (%expr-elems;)?&gt;
&lt;!ELEMENT throw (%expr-elems;)&gt;
&lt;!ELEMENT throws EMPTY&gt;
&lt;!ATTLIST throws
    exception CDATA #REQUIRED&gt;
&lt;!ELEMENT new (type,arguments,anonymous-class?)&gt;
&lt;!ELEMENT type EMPTY&gt;
&lt;!ATTLIST type
    primitive CDATA #IMPLIED
    name CDATA #REQUIRED
    dimensions CDATA #IMPLIED
    idref IDREF #IMPLIED&gt;
&lt;!ELEMENT new-array (type,dim-expr*,array-initializer?)&gt;
&lt;!ATTLIST new-array
    dimensions CDATA #REQUIRED&gt;
&lt;!ELEMENT dim-expr (%expr-elems;)&gt;
&lt;!ELEMENT local-variable (type,(static-initializer|array-initializer|%expr-elems;)?)&gt;
&lt;!ATTLIST local-variable
    name CDATA #REQUIRED
    id ID #REQUIRED
    continued CDATA #IMPLIED
    %mod-final;&gt;
&lt;!ELEMENT array-initializer (array-initializer|%expr-elems;)*&gt;
&lt;!ATTLIST array-initializer
    length CDATA #REQUIRED&gt;
&lt;!ELEMENT arguments (%expr-elems;)*&gt;
&lt;!ELEMENT literal-string EMPTY&gt;
&lt;!ATTLIST literal-string
    value CDATA #REQUIRED&gt;
&lt;!ELEMENT literal-char EMPTY&gt;
&lt;!ATTLIST literal-char
    value CDATA #REQUIRED&gt;
&lt;!ELEMENT literal-number EMPTY&gt;
&lt;!ATTLIST literal-number
    value CDATA #REQUIRED
    %kind-attribute;
    base CDATA "10"&gt;
&lt;!ELEMENT var-ref EMPTY&gt;
&lt;!ATTLIST var-ref
    name CDATA #REQUIRED
    idref IDREF #IMPLIED&gt;
&lt;!ELEMENT field-access (%expr-elems;)&gt;
&lt;!ATTLIST field-access
    field CDATA #REQUIRED&gt;
&lt;!ELEMENT var-set EMPTY&gt;
&lt;!ATTLIST var-set
    name CDATA #REQUIRED&gt;
&lt;!ELEMENT field-set (%expr-elems;)&gt;
&lt;!ATTLIST field-set
    field CDATA #REQUIRED&gt;
&lt;!ELEMENT package-decl EMPTY&gt;
&lt;!ATTLIST package-decl
    name CDATA #REQUIRED&gt;
&lt;!ELEMENT assignment-expr (lvalue,(%expr-elems;))&gt;
&lt;!ATTLIST assignment-expr
    op CDATA #REQUIRED&gt;
&lt;!ELEMENT lvalue (var-set|field-set|%expr-elems;)&gt;
&lt;!ELEMENT instanceof-test ((%expr-elems;),type)&gt;
&lt;!ELEMENT binary-expr ((%expr-elems;),(%expr-elems;))&gt;
&lt;!ATTLIST binary-expr
    op CDATA #REQUIRED&gt;
&lt;!ELEMENT paren (%expr-elems;)&gt;
&lt;!ELEMENT unary-expr (%expr-elems;)&gt;
&lt;!ATTLIST unary-expr
    op CDATA #REQUIRED
    post (true|false) #IMPLIED&gt;
&lt;!ELEMENT cast-expr (type,(%expr-elems;))&gt;
&lt;!ELEMENT literal-boolean EMPTY&gt;
&lt;!ATTLIST literal-boolean
    value (true|false) #REQUIRED&gt;
&lt;!ELEMENT literal-null EMPTY&gt;
&lt;!ELEMENT synchronized (expr,block)&gt;
&lt;!ELEMENT expr (%expr-elems;)&gt;
&lt;!ELEMENT if (test,true-case,false-case?)&gt;
&lt;!ELEMENT test (%expr-elems;)&gt;
&lt;!ELEMENT true-case (%stmt-elems;)?&gt;
&lt;!ELEMENT false-case (%stmt-elems;)?&gt;
&lt;!ELEMENT array-ref (base,offset)&gt;
&lt;!ELEMENT base (%expr-elems;)&gt;
&lt;!ELEMENT offset (%expr-elems;)&gt;
&lt;!ELEMENT static-initializer (%stmt-elems;)*&gt;
&lt;!ELEMENT instance-initializer (%stmt-elems;)*&gt;
&lt;!ELEMENT super-call (arguments)&gt;
&lt;!ELEMENT this-call (arguments)&gt;
&lt;!ELEMENT super EMPTY&gt;
&lt;!ELEMENT this EMPTY&gt;
&lt;!ELEMENT loop (init*,test?,update*,(%stmt-elems;)?)&gt;
&lt;!ATTLIST loop
    kind (for|while) #IMPLIED
    %location-info;&gt;
&lt;!ELEMENT init (local-variable|%expr-elems;)*&gt;
&lt;!ELEMENT update (%expr-elems;)&gt;
&lt;!ELEMENT do-loop ((%stmt-elems;)?,test?)&gt;
&lt;!ELEMENT try ((%stmt-elems;),catch*,finally?)&gt;
&lt;!ELEMENT catch (formal-argument,(%stmt-elems;)?)&gt;
&lt;!ELEMENT finally (%stmt-elems;)&gt;
&lt;!ELEMENT continue EMPTY&gt;
&lt;!ATTLIST continue
    targetname CDATA #IMPLIED&gt;
&lt;!ELEMENT break EMPTY&gt;
&lt;!ATTLIST break
    targetname CDATA #IMPLIED&gt;
&lt;!ELEMENT conditional-expr ((%expr-elems;),(%expr-elems;),(%expr-elems;))&gt;
&lt;!ELEMENT switch ((%expr-elems;),switch-block+)&gt;
&lt;!ELEMENT switch-block ((case|default-case)+,(%stmt-elems;)*)&gt;
&lt;!ELEMENT case (%expr-elems;)&gt;
&lt;!ELEMENT default-case EMPTY&gt;
</pre>
</small>

<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="references">References</a></h3>

<P><A NAME="ref-1"><strong>[1]</strong></A>
S. S. Alhir.
<EM>UML in a Nutshell</EM>.
O'Reilly &amp; Associates, Inc., 1998.

<P><A NAME="ref-2"><strong>[2]</strong></A>
V. Apparao, S. Byrne, M. Champion, S. Isaacs, I. Jacobs, A. L. Hors, G. Nicol,
  J. Robie, R. Sutor, C. Wilson, and L. Wood.
Document object model (DOM) level 1.
W3C Recommendation, October 1998.
<a href="http://www.w3.org/TR/REC-DOM-Level-1">http://www.w3.org/TR/REC-DOM-Level-1</a>.

<P><A NAME="ref-3"><strong>[3]</strong></A>
K. Arnold and J. Gosling.
<EM>The Java Programming Language</EM>.
Addison-Wesley, Reading, Massachusetts, 1998.

<P><A NAME="ref-4"><strong>[4]</strong></A>
G. J. Badros.
JavaML Home Page.
<a href="http://www.cs.washington.edu/homes/gjb/JavaML">http://www.cs.washington.edu/homes/gjb/JavaML</a>.

<P><A NAME="ref-5"><strong>[5]</strong></A>
G. J. Badros and A. Borning.
The Cassowary linear arithmetic constraint solving algorithm:
  Interface and implementation.
Technical Report UW-CSE-98-06-04, University of Washington, Seattle,
  Washington, June 1998.

  <a href="http://www.cs.washington.edu/research/constraints/cassowary/cassowary-tr.pdf">http://www.cs.washington.edu/research/constraints/cassowary/cassowary-tr.pdf</a>.

<P><A NAME="ref-6"><strong>[6]</strong></A>
G. J. Badros and D. Notkin.
A framework for preprocessor-aware C source code analyses.
<EM>Software &#151; Practice and Experience</EM>, 2000.
To appear.

<P><A NAME="ref-7"><strong>[7]</strong></A>
P. V. Biron and A. Malhotra.
Xml scheme part 2: Datatypes.
W3C Working Draft, November 1999.
<a href="http://www.w3.org/TR/xmlschema-2">http://www.w3.org/TR/xmlschema-2</a>.

<P><A NAME="ref-8"><strong>[8]</strong></A>
B. Bos, H. W. Lie, C. Lilley, and I. Jacobs.
Cascading style sheets, level 2.
W3C Working Draft, Jan. 1998.
<a href="http://www.w3.org/TR/WD-css2/">http://www.w3.org/TR/WD-css2/</a>.

<P><A NAME="ref-9"><strong>[9]</strong></A>
T. Bray, J. Paoli, and C. M. Sperberg-McQueen.
Extensible markup language (XML) 1.0.
W3C Recommendation, February 1998.
<a href="http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</a>.

<P><A NAME="ref-10"><strong>[10]</strong></A>
British Standards Institution.
Modula-2 draft international standard, iso-94, June 1994.

<P><A NAME="ref-11"><strong>[11]</strong></A>
Y.-F. Chen.
The c program database and its applications.
In <EM>Proceedings of the Summer 1989 USENIX Conference</EM>, pages
  157-171, Baltimore, 1989.

<P><A NAME="ref-12"><strong>[12]</strong></A>
J. Clark.
James' DSSSL engine (JADE).
<a href="http://www.jclark.com/jade">http://www.jclark.com/jade</a>.

<P><A NAME="ref-13"><strong>[13]</strong></A>
J. Clark.
XP version 0.5, 1998.
<a href="http://www.jclark.com/xml/xp">http://www.jclark.com/xml/xp</a>.

<P><A NAME="ref-14"><strong>[14]</strong></A>
J. Clark.
XSL transformations.
W3C Recommendation, November 1999.
<a href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a>.

<P><A NAME="ref-15"><strong>[15]</strong></A>
J. Clark.
XT version 19991105, November 1999.
<a href="http://www.jclark.com/xml/xt.html">http://www.jclark.com/xml/xt.html</a>.

<P><A NAME="ref-16"><strong>[16]</strong></A>
J. Clark and S. DeRose.
XML path language (xpath) version 1.0.
W3C Recommendation, November 1999.
<a href="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</a>.

<P><A NAME="ref-17"><strong>[17]</strong></A>
W. F. Clocksin and C. S. Mellish.
<EM>Programming in Prolog</EM>.
Springer-Verlag, Berlin, fourth edition, 1994.

<P><A NAME="ref-18"><strong>[18]</strong></A>
R. F. Crew.
ASTLOG: A language for examining abstract syntax trees.
In <EM>Proceedings of the USENIX Conference on Domain-Specific
  Languages</EM>, Santa Barbara, CA, October 1997.

<P><A NAME="ref-19"><strong>[19]</strong></A>
S. Deach.
Extensible stylesheet language (xsl) specification.
W3C Working Draft, January 2000.
<a href="http://www.w3.org/TR/WD-xsl">http://www.w3.org/TR/WD-xsl</a>.

<P><A NAME="ref-20"><strong>[20]</strong></A>
E. Derksen and C. Cooper.
Perl XML::DOM module.
<a href="http://users.erols.com/enno/dom">http://users.erols.com/enno/dom</a>.

<P><A NAME="ref-21"><strong>[21]</strong></A>
D. Dougherty.
<EM>Sed and Awk</EM>.
O'Reilly &amp; Associates, Inc., Sebastopol, California, 1990.

<P><A NAME="ref-22"><strong>[22]</strong></A>
C. K. Duby, S. Meyers, and S. P. Reiss.
CCEL: A metalanguage for C++.
In <EM>Proceedings of the USENIX 1992 C++ Conference</EM>, Portland,
  Oregon, August 1992.

<P><A NAME="ref-23"><strong>[23]</strong></A>
M. Ernst, G. J. Badros, and D. Notkin.
An empirical analysis of C preprocessor use.
<EM>IEEE Transactions on Software Engineering</EM>, 2000.
To appear.

<P><A NAME="ref-24"><strong>[24]</strong></A>
M. Fernandez, J. Sim&#233;on, and P. Wadler.
XML query language: Experiences and exemplars, 1999.
<a href="http://www-db.research.bell-labs.com/user/simeon/xquery.html">http://www-db.research.bell-labs.com/user/simeon/xquery.html</a>.

<P><A NAME="ref-25"><strong>[25]</strong></A>
D. Flanagan.
<EM>Java in a Nutshell</EM>.
O'Reilly &amp; Associates, Inc., Sebastopol, California, 2nd edition,
  1997.

<P><A NAME="ref-26"><strong>[26]</strong></A>
A. Goldberg and D. Robson.
<EM>Smalltalk-80: The Language</EM>.
Addison-Wesley, Reading, Massachusetts, 1989.

<P><A NAME="ref-27"><strong>[27]</strong></A>
C. F. Goldfarb and P. Prescod.
<EM>The XML Handbook</EM>.
Prentice Hall PTR, 1998.

<P><A NAME="ref-28"><strong>[28]</strong></A>
M. Goosens and S. Rahtz.
<EM>The LaTeX Web Companion</EM>.
Addison Wesley Longman, 1999.

<P><A NAME="ref-29"><strong>[29]</strong></A>
W. G. Griswold, D. C. Atkinson, and C. McCurdy.
Fast, flexible syntactic pattern matching and processing.
In <EM>Proceedings of the IEEE 1996 Workshop on Program
  Comprehension</EM>, March 1996.

<P><A NAME="ref-30"><strong>[30]</strong></A>
A. N. Habermann and D. Notkin.
Gandalf: Software development environments.
<EM>IEEE Transactions on Software Engineering</EM>, pages
  pp. 1117-1127, 1986.

<P><A NAME="ref-31"><strong>[31]</strong></A>
E. Hood.
perlSGML library.
<a href="http://www.oac.uci.edu/indiv/ehood/perlSGML.html">http://www.oac.uci.edu/indiv/ehood/perlSGML.html</a>.

<P><A NAME="ref-32"><strong>[32]</strong></A>
IBM.
Jikes java compiler.
<a href="http://www.alphaworks.ibm.com/tech/Jikes">http://www.alphaworks.ibm.com/tech/Jikes</a>.

<P><A NAME="ref-33"><strong>[33]</strong></A>
IBM AlphaWorks.
XML diff and merge tool.
<a href="http://www.alphaworks.ibm.com/tech/xmldiffmerge">http://www.alphaworks.ibm.com/tech/xmldiffmerge</a>.

<P><A NAME="ref-34"><strong>[34]</strong></A>
IBM AlphaWorks.
XML for C++.
<a href="http://www.alphaworks.ibm.com/tech/xml4c">http://www.alphaworks.ibm.com/tech/xml4c</a>.

<P><A NAME="ref-35"><strong>[35]</strong></A>
IBM AlphaWorks.
XML metadata interchange (XMI) toolkit.
<a href="http://www.alphaworks.ibm.com/tech/xmitoolkit">http://www.alphaworks.ibm.com/tech/xmitoolkit</a>.

<P><A NAME="ref-36"><strong>[36]</strong></A>
Icon I.S.
XML spy 3.0beta2.
<a href="http://www.xmlspy.com">http://www.xmlspy.com</a>.

<P><A NAME="ref-37"><strong>[37]</strong></A>
ISO.
Standard generalized markup language (SGML).
ISO 8879, 1986.
<a href="http://www.iso.ch/cate/d16387.html">http://www.iso.ch/cate/d16387.html</a>.

<P><A NAME="ref-38"><strong>[38]</strong></A>
ISO/IEC.
Document style semantics and specification language (DSSSL).
ISO/IEC 10179, 1996.

<P><A NAME="ref-39"><strong>[39]</strong></A>
M. H. Kay.
<EM>SAXON</EM>.
<a href="http://users.iclway.co.uk/mhkay/saxon/">http://users.iclway.co.uk/mhkay/saxon/</a>.

<P><A NAME="ref-40"><strong>[40]</strong></A>
N. Kiesel, A. Sch&#252;rr, and B. Westfechtel.
GRAS, a graph-oriented (software) engineering database system.
<EM>Information Systems</EM>, 20(1):21-52, 1995.
Oxford: Pergamon Press.

<P><A NAME="ref-41"><strong>[41]</strong></A>
J. Korn, Y. Chen, and E. Koutsofios.
Chava: Reverse engineering and tracking of java applets.
In <EM>Proceedings of the Sixth Working Conference on Reverse
  Engineering</EM>, pages 314-325, October 1999.

<P><A NAME="ref-42"><strong>[42]</strong></A>
J. R. Levine.
<EM>Lex &amp; Yacc</EM>.
O'Reilly &amp; Associates, Inc., Sebastopol, California, 2nd edition,
  1992.

<P><A NAME="ref-43"><strong>[43]</strong></A>
Megginson Technologies.
SAX 1.0: The simple API for XML.
Web document, 1999.
<a href="http://www.megginson.com/SAX">http://www.megginson.com/SAX</a>.

<P><A NAME="ref-44"><strong>[44]</strong></A>
Microsoft.
XML Notepad Beta 1.5.
<a href="http://msdn.microsoft.com/xml/notepad/">http://msdn.microsoft.com/xml/notepad</a>.

<P><A NAME="ref-45"><strong>[45]</strong></A>
R. C. Miller and B. A. Myers.
Lightweight structured text processing.
In <EM>Proceedings of USENIX 1999</EM>, Monterey, CA, 1999.

<P><A NAME="ref-46"><strong>[46]</strong></A>
S. E. Sand&#248;and K.-T. Kalleberg.
Software development foundation, February 2000.
<a href="http://sds.yi.org">http://sds.yi.org</a>.

<P><A NAME="ref-47"><strong>[47]</strong></A>
C. Simonyi.
Intentional programming - innovation in the legacy age.
International Federation for Information Processing WG 2.1 meeting,
  June 1996.

<P><A NAME="ref-48"><strong>[48]</strong></A>
D. Soroker, M. Karasick, J. Barton, and D. Streeter.
Extension mechanisms in montana.
In <EM>Proceedings of 8th Israeli Conference on Computer-Based
  Systems and Software Engineering</EM>, June 1997.

<P><A NAME="ref-49"><strong>[49]</strong></A>
B. Stroustrup.
<EM>The C++ Programming Language</EM>.
Addison-Wesley, Reading, Massachusetts, 3rd edition, 1997.

<P><A NAME="ref-50"><strong>[50]</strong></A>
Sun Microsystems.
Applet resources, February 2000.
<a href="http://java.sun.com/applets/">http://java.sun.com/applets/</a>.

<P><A NAME="ref-51"><strong>[51]</strong></A>
H. S. Thompson, D. Beech, M. Maloney, and N. Mendelsohn.
Xml scheme part 1: Structures.
W3C Working Draft, November 1999.
<a href="http://www.w3.org/TR/xmlschema-1">http://www.w3.org/TR/xmlschema-1</a>.

<P><A NAME="ref-52"><strong>[52]</strong></A>
University of Edinburgh Language Technology Group.
LT XML vesion 1.1.
<a href="http://www.ltg.ed.ac.uk/software/xml">http://www.ltg.ed.ac.uk/software/xml</a>.

<p><span class="index"><a href="#top">[top]</a></span>


<h3><a name="vitae">Vitae</a></h3>

<IMG ALT="Greg J. Badros" SRC="./gjb-face.gif" width="90">
<strong><a href="http://www.cs.washington.edu/homes/gjb">Greg J. 
Badros</a></strong> is a final-year Ph.D. candidate at the
<a href="http://www.cs.washington.edu">University of Washington</a>
in Seattle, Washington where he earned his
M.Sc. degree in 1998.  He graduated <i>magna cum laude</i> with a
B.S. degree in <a href="http://www.math.duke.edu">Mathematics</a> and 
<a href="http://www.cs.duke.edu">Computer Science</a> from
<a href="http://www.duke.edu">Duke University</a> in
1995.  He is the primary author of the <a
href="http://scwm.mit.edu">Scheme Constraints Window Manager</a> and the
<a href="http://www.cs.washington.edu/research/constraints/cassowary/">Cassowary
Constraint Solving Toolkit</a>.  His research interests include
constraint technology, software engineering, languages, and the
internet.

<hr>
<a href="#introduction">Introduction</a> &nbsp;
<a href="#background">Background</a> &nbsp;
<a href="#javaml">Java Markup Language (JavaML)</a> &nbsp; <br>
<a href="#leveraging-xml">Leveraging XML</a> &nbsp;
<a href="#related-work">Related work</a>  &nbsp;
<a href="#future-work">Future work</a>  &nbsp;
<a href="#conclusion">Conclusion</a>  &nbsp;  <br>
<a href="#acknowledgments">Acknowledgments</a> &nbsp;
<a href="#javaml-dtd">Appendix A - JavaML DTD</a> &nbsp;
<a href="#references">References</a>  &nbsp;
<a href="#vitae">Vitae</a> 

<p><span class="index"><a href="#top">[top]</a></span>

<hr>
<address>
      <a href="http://www.cs.washington.edu/homes/gjb">Greg J. Badros</a> / 
      <a href="http://www.cs.washington.edu">U Washington Computer Science and Engineering</a> /
      <a href="http://www.cs.washington.edu/homes/gjb/JavaML/">JavaML Home Page</a> /
      <a href="mailto:gjb@cs.washington.edu">gjb@cs.washington.edu</a></address>
</body>
</html>
